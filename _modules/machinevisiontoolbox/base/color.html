

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>machinevisiontoolbox.base.color &mdash; Machine Vision Toolbox 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Machine Vision Toolbox
              <img src="../../../_static/VisionToolboxLogo_CircBlack.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../high-level.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low-level.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../blocks.html">bdsim blocks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Machine Vision Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">machinevisiontoolbox.base.color</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for machinevisiontoolbox.base.color</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># import io as io</span>
<span class="kn">from</span> <span class="nn">machinevisiontoolbox.base.data</span> <span class="kn">import</span> <span class="n">mvtb_path_to_datafile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="nn">cv</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">urllib.request</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">machinevisiontoolbox.base.types</span> <span class="kn">import</span> <span class="n">float_image</span><span class="p">,</span> <span class="n">int_image</span>

<span class="c1"># TODO</span>
<span class="c1"># need to remove references to image class here</span>
<span class="c1"># bring col2im from .. into here</span>
<span class="c1"># perhaps split out colorimetry and put ..</span>


<span class="k">def</span> <span class="nf">_loaddata</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from filename</span>

<span class="sd">    :param filename: filename</span>
<span class="sd">    :type filename: string</span>
<span class="sd">    :param **kwargs: keyword arguments for numpy.genfromtxt</span>
<span class="sd">    :type **kwargs: keyword arguments in name, value pairs</span>
<span class="sd">    :return: data</span>
<span class="sd">    :rtype: numpy array</span>

<span class="sd">    ``_loaddata(filename)`` returns ``data`` from ``filename``, otherwise</span>
<span class="sd">    returns None</span>

<span class="sd">    Example:</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Comments are assumed to be as original data files were part of the</span>
<span class="sd">          MATLAB machine vision toolbox, which can be changed using kwargs.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">mvtb_path_to_datafile</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># import filename, which we expect to be a .dat file</span>
        <span class="c1"># columns for wavelength and spectral data</span>
        <span class="c1"># assume column delimiters are whitespace, so for .csv files,</span>
        <span class="c1"># replace , with &#39; &#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">())</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">clean_lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">)</span>
            <span class="c1"># default delimiter whitespace</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">clean_lines</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot open </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_loaddata: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not read the specified data filename&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="n">_spectra</span> <span class="o">=</span> <span class="p">{}</span>


<div class="viewcode-block" id="loadspectrum">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.loadspectrum">[docs]</a>
<span class="k">def</span> <span class="nf">loadspectrum</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load spectrum data</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: array_like(N)</span>
<span class="sd">    :param filename: filename, an extension of ``.dat`` will be added if not</span>
<span class="sd">        provided</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param kwargs: keyword arguments for scipy.interpolate.interp1d</span>
<span class="sd">    :return: interpolated spectral data and corresponding wavelength</span>
<span class="sd">    :rtype: ndarray(N), ndarray(N,D)</span>

<span class="sd">    Load spectral data from the file</span>
<span class="sd">    ``filename`` and interpolate it to the wavelengths [meters] specified in 𝜆.</span>
<span class="sd">    The spectral data can be scalar (D=1) or vector (D&gt;1) valued.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import loadspectrum</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; sun = loadspectrum(l, &quot;solar&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(sun[:5])</span>

<span class="sd">    .. note::</span>

<span class="sd">        - The file contains columns of data, white space separated, and the</span>
<span class="sd">          first column is wavelength in metres. The remaining columns are</span>
<span class="sd">          linearly interpolated and returned as columns of S.</span>
<span class="sd">        - The files are kept in the private folder inside the ``mvtb_data``</span>
<span class="sd">          package with extension .dat</span>
<span class="sd">        - Default interpolation mode is linear, to change this use ``kind=`` a</span>
<span class="sd">          string such as &quot;slinear&quot;, &quot;quadratic&quot;, &quot;cubic&quot;, etc.  See</span>
<span class="sd">          `scipy.interpolate.interp1d</span>
<span class="sd">          &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html&gt;`_</span>
<span class="sd">          for more info.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_spectra</span>

    <span class="k">if</span> <span class="n">filename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_spectra</span><span class="p">:</span>
        <span class="c1"># save an interpolator for every spectrum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.dat&quot;</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s2">&quot;.dat&quot;</span>
        <span class="n">_spectra</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">_loaddata</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="c1"># check valid input</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="c1"># interpolate data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_spectra</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
        <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spectrum</span></div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="blackbody">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.blackbody">[docs]</a>
<span class="k">def</span> <span class="nf">blackbody</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute blackbody emission spectrum</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float, array_like(N)</span>
<span class="sd">    :param T: blackbody temperature [K]</span>
<span class="sd">    :type T: float</span>
<span class="sd">    :return: blackbody radiation power density</span>
<span class="sd">    :rtype: float, ndarray(N)</span>

<span class="sd">    Compute the blackbody radiation power density [W/m^3]</span>
<span class="sd">    at the wavelength 𝜆 [m] and temperature T [K].</span>

<span class="sd">    If 𝜆 is an array, then the result is an array of</span>
<span class="sd">    blackbody radiation power density at the corresponding elements of 𝜆.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import blackbody</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; e = blackbody(l, 6500)                # emission of sun</span>
<span class="sd">        &gt;&gt;&gt; print(e[:5])</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># physical constants</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.99792458e8</span>  <span class="c1"># m/s         (speed of light)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mf">6.626068e-34</span>  <span class="c1"># m2 kg / s   (Planck&#39;s constant)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mf">1.3806503e-23</span>  <span class="c1"># J K-1      (Boltzmann&#39;s constant)</span>

    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="n">e</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">λ</span><span class="o">**</span><span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="n">k</span> <span class="o">/</span> <span class="n">T</span> <span class="o">/</span> <span class="n">λ</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span></div>



<div class="viewcode-block" id="lambda2rg">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.lambda2rg">[docs]</a>
<span class="k">def</span> <span class="nf">lambda2rg</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RGB chromaticity coordinates</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float, array_like(N)</span>
<span class="sd">    :param e: illlumination spectrum defined at the wavelengths 𝜆</span>
<span class="sd">    :type e: array_like(N), optional</span>
<span class="sd">    :return: rg-chromaticity</span>
<span class="sd">    :rtype: ndarray(2), ndarray(N,2)</span>

<span class="sd">    Compute the rg-chromaticity coordinate for illumination at the specific</span>
<span class="sd">    wavelength :math:`\lambda` [m]. If :math:`\lambda` is an array, then the</span>
<span class="sd">    result is an array where the rows are the chromaticity coordinates at the</span>
<span class="sd">    corresponding elements of :math:`\lambda`.</span>

<span class="sd">    If ``e`` is given, compute the rg-chromaticity coordinate for an</span>
<span class="sd">    illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding</span>
<span class="sd">    wavelengths of :math:`\lambda`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import lambda2rg, loadspectrum</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; lambda2rg(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; lambda2rg([550e-9, 600e-9])</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; e = loadspectrum(l, &quot;solar&quot;)</span>
<span class="sd">        &gt;&gt;&gt; lambda2rg(l, e)</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Data from `Color &amp; Vision Research Laboratory &lt;http://cvrl.ioo.ucl.ac.uk&gt;`_</span>
<span class="sd">        - From Table I(5.5.3) of Wyszecki &amp; Stiles (1982). (Table 1(5.5.3) of</span>
<span class="sd">          Wyszecki &amp; Stiles (1982) gives the Stiles &amp; Burch functions in</span>
<span class="sd">          250 cm-1 steps, while Table I(5.5.3) of Wyszecki &amp; Stiles (1982)</span>
<span class="sd">          gives them in interpolated 1 nm steps.).</span>
<span class="sd">        - The Stiles &amp; Burch 2-deg CMFs are based on measurements made on</span>
<span class="sd">          10 observers. The data are referred to as pilot data, but probably</span>
<span class="sd">          represent the best estimate of the 2 deg CMFs, since, unlike the CIE</span>
<span class="sd">          2 deg functions (which were reconstructed from chromaticity data),</span>
<span class="sd">          they were measured directly.</span>
<span class="sd">        - These CMFs differ slightly from those of Stiles &amp; Burch (1955). As</span>
<span class="sd">          noted in footnote a on p. 335 of Table 1(5.5.3) of Wyszecki &amp;</span>
<span class="sd">          Stiles (1982), the CMFs have been &quot;corrected in accordance with</span>
<span class="sd">          instructions given by Stiles &amp; Burch (1959)&quot; and renormalized to</span>
<span class="sd">          primaries at 15500 (645.16), 19000 (526.32), and 22500 (444.44) cm-1.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`lambda2xy` :func:`cmfrgb`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check input</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rgb</span> <span class="o">=</span> <span class="n">cmfrgb</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">λ</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of wavelengths and intensities must match&quot;</span><span class="p">)</span>
        <span class="n">rgb</span> <span class="o">=</span> <span class="n">cmfrgb</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">cc</span> <span class="o">=</span> <span class="n">tristim2cc</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cc</span></div>



<div class="viewcode-block" id="cmfrgb">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.cmfrgb">[docs]</a>
<span class="k">def</span> <span class="nf">cmfrgb</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RGB color matching function</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: array_like(N)</span>
<span class="sd">    :param e: illlumination spectrum defined at the wavelengths 𝜆</span>
<span class="sd">    :type e: array_like(N), optional</span>
<span class="sd">    :return: RGB color matching function</span>
<span class="sd">    :rtype: ndarray(3), ndarray(N,3)</span>

<span class="sd">    The color matching function is the CIE RGB tristimulus required to match a</span>
<span class="sd">    particular wavelength excitation.</span>

<span class="sd">    Compute the CIE RGB color matching function for illumination at wavelength</span>
<span class="sd">    :math:`\lambda` [m]. This is the RGB tristimulus that has the same visual</span>
<span class="sd">    sensation as the single wavelength :math:`\lambda`.</span>

<span class="sd">    If 𝜆 is an array then each row of the result is the color matching function</span>
<span class="sd">    of the corresponding element of :math:`\lambda`.</span>

<span class="sd">    If ``e`` is given, compute the CIE color matching function for an</span>
<span class="sd">    illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding</span>
<span class="sd">    wavelengths of :math:`\lambda`. This is the tristimulus that has the same</span>
<span class="sd">    visual sensation as :math:`\texttt{e}(\lambda)`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import cmfrgb, loadspectrum</span>
<span class="sd">        &gt;&gt;&gt; cmfrgb(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; cmfrgb([550e-9, 600e-9])</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; e = loadspectrum(l, &quot;solar&quot;)</span>
<span class="sd">        &gt;&gt;&gt; cmfrgb(l, e)</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`~lambda2rg`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>  <span class="c1"># λ is (N,1)</span>

    <span class="n">cmf</span> <span class="o">=</span> <span class="n">loadspectrum</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="s2">&quot;cmfrgb&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># approximate rectangular integration</span>
    <span class="c1"># assume steps are equal sized</span>
    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s2">&quot;row&quot;</span><span class="p">)</span>  <span class="c1"># e is a vector Nx1</span>
        <span class="n">dλ</span> <span class="o">=</span> <span class="n">λ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">λ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">@</span> <span class="n">cmf</span><span class="p">)</span> <span class="o">/</span> <span class="n">cmf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dλ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">cmf</span>

    <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="tristim2cc">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.tristim2cc">[docs]</a>
<span class="k">def</span> <span class="nf">tristim2cc</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tristimulus to chromaticity coordinates</span>

<span class="sd">    :param tri: RGB or XYZ tristimulus</span>
<span class="sd">    :type tri: array_like(3), array_like(N,3), ndarray(N,M,3)</span>
<span class="sd">    :return: chromaticity coordinates</span>
<span class="sd">    :rtype: ndarray(2), ndarray(N,2), ndarray(N,N,2)</span>

<span class="sd">    Compute the chromaticity coordinate corresponding</span>
<span class="sd">    to the tristimulus ``tri``. Multiple tristimulus values can be</span>
<span class="sd">    given as rows of ``tri``, in which case the chromaticity</span>
<span class="sd">    coordinates are the corresponding rows of the result.</span>

<span class="sd">    .. math::</span>

<span class="sd">        r = \frac{R}{R+G+B},\, g = \frac{G}{R+G+B},\, b = \frac{B}{R+G+B}</span>

<span class="sd">    or</span>

<span class="sd">    .. math::</span>

<span class="sd">        x = \frac{X}{X+Y+Z},\,  y = \frac{Y}{X+Y+Z},\,  z = \frac{Z}{X+Y+Z}</span>

<span class="sd">    In either case, :math:`r+g+b=1` and :math:`x+y+z=1` so one of the three</span>
<span class="sd">    chromaticity coordinates is redundant.</span>

<span class="sd">    If ``tri`` is a color image, a 3D array, then compute the chromaticity</span>
<span class="sd">    coordinates corresponding to every pixel in the tristimulus image. The</span>
<span class="sd">    result is an image with two planes corresponding to r and g, or x and y</span>
<span class="sd">    (depending on whether the input image was RGB or XYZ).</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import tristim2cc, iread</span>
<span class="sd">        &gt;&gt;&gt; tristim2cc([100, 200, 50])</span>
<span class="sd">        &gt;&gt;&gt; img, _ = iread(&#39;flowers1.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cc = tristim2cc(img)</span>
<span class="sd">        &gt;&gt;&gt; cc.shape</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO check if tri is correct shape? can be vector or matrix</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tri</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">tri</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># N x 3 case</span>
        <span class="c1"># each row is R G B, or X Y Z</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># ?? TODO</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">ss</span>

        <span class="c1">#  / np.sum(XYZ, axis=1)[..., np.newaxis];</span>

    <span class="k">elif</span> <span class="n">tri</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">tri</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># N x M x 3 case</span>

        <span class="c1"># tri is given as an image</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># could also use np.tile</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">ss</span>

    <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">tri</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad shape input&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cc</span></div>



<div class="viewcode-block" id="lambda2xy">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.lambda2xy">[docs]</a>
<span class="k">def</span> <span class="nf">lambda2xy</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    XY-chromaticity coordinates for a given wavelength 𝜆 [meters]</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float or array_like(N)</span>
<span class="sd">    :return: xy-chromaticity</span>
<span class="sd">    :rtype: ndarray(2), ndarray(N,2)</span>

<span class="sd">    Compute the xy-chromaticity coordinate for illumination at the specific</span>
<span class="sd">    wavelength :math:`\lambda` [m]. If :math:`\lambda` is an array, then the</span>
<span class="sd">    result is an array where the rows are the chromaticity coordinates at the</span>
<span class="sd">    corresponding elements of :math:`\lambda`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import lambda2xy</span>
<span class="sd">        &gt;&gt;&gt; lambda2xy(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; lambda2xy([550e-9, 600e-9])</span>


<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`lambda2rg` :func:`cmfxyz` :func:`ccxyz`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># argcheck</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="n">cmf</span> <span class="o">=</span> <span class="n">cmfxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">tristim2cc</span><span class="p">(</span><span class="n">cmf</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xy</span></div>



<div class="viewcode-block" id="cmfxyz">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.cmfxyz">[docs]</a>
<span class="k">def</span> <span class="nf">cmfxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Color matching function for xyz tristimulus</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: array_like(N)</span>
<span class="sd">    :param e: illlumination spectrum defined at the wavelengths 𝜆</span>
<span class="sd">    :type e: array_like(N), optional</span>
<span class="sd">    :return: XYZ color matching function</span>
<span class="sd">    :rtype: ndarray(3), ndarray(N,3)</span>

<span class="sd">    The color matching function is the XYZ tristimulus required to match a</span>
<span class="sd">    particular wavelength excitation.</span>

<span class="sd">    Compute the CIE XYZ color matching function for illumination at wavelength</span>
<span class="sd">    :math:`\lambda` [m]. This is the XYZ tristimulus that has the same visual</span>
<span class="sd">    sensation as the single wavelength :math:`\lambda`.</span>

<span class="sd">    If :math:`\lambda` is an array then each row of the result is the color</span>
<span class="sd">    matching function of the corresponding element of :math:`\lambda`.</span>

<span class="sd">    If ``e`` is given, compute the CIE XYZ color matching function for an</span>
<span class="sd">    illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding</span>
<span class="sd">    wavelengths of :math:`\lambda`. This is the XYZ tristimulus that has the</span>
<span class="sd">    same visual sensation as :math:`\texttt{e}(\lambda)`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import cmfxyz, loadspectrum</span>
<span class="sd">        &gt;&gt;&gt; cmfxyz(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; cmfxyz([550e-9, 600e-9])</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; e = loadspectrum(l, &quot;solar&quot;)</span>
<span class="sd">        &gt;&gt;&gt; cmfxyz(l, e)</span>

<span class="sd">    .. note::  CIE 1931 2-deg XYZ CMFs from from `Color &amp; Vision Research Laboratory &lt;http://cvrl.ioo.ucl.ac.uk&gt;`_</span>


<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`lambda2xy` :func:`ccxyz`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="n">cmfxyz</span> <span class="o">=</span> <span class="n">loadspectrum</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="s2">&quot;cmfxyz&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># approximate rectangular integration</span>
        <span class="n">dλ</span> <span class="o">=</span> <span class="n">λ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">λ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">XYZ</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">@</span> <span class="n">cmfxyz</span> <span class="o">*</span> <span class="n">dλ</span>
        <span class="k">return</span> <span class="n">XYZ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cmfxyz</span></div>



<div class="viewcode-block" id="luminos">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.luminos">[docs]</a>
<span class="k">def</span> <span class="nf">luminos</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Photopic luminosity function</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float, array_like(N)</span>
<span class="sd">    :return: luminosity</span>
<span class="sd">    :rtype: float, ndarray(N)</span>

<span class="sd">    Return the photopic luminosity function for the wavelengths in</span>
<span class="sd">    :math:`\lambda` [m]. If :math:`\lambda`𝜆 is an array then the result is an</span>
<span class="sd">    array whose elements are the luminosity at the corresponding</span>
<span class="sd">    :math:`\lambda`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import luminos</span>
<span class="sd">        &gt;&gt;&gt; luminos(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; luminos([550e-9, 600e-9])</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Luminosity has units of lumens, which are the intensity with which</span>
<span class="sd">          wavelengths are perceived by the light-adapted human eye.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`rluminos`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="n">luminos</span> <span class="o">=</span> <span class="n">loadspectrum</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="s2">&quot;photopicluminosity&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">luminos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">luminos</span> <span class="o">=</span> <span class="n">luminos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">luminos</span> <span class="o">*</span> <span class="mi">683</span>  <span class="c1"># photopic luminosity is the Y color matching function</span></div>



<div class="viewcode-block" id="rluminos">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.rluminos">[docs]</a>
<span class="k">def</span> <span class="nf">rluminos</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relative photopic luminosity function</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float, array_like(N)</span>
<span class="sd">    :return: relative luminosity</span>
<span class="sd">    :rtype: float, ndarray(N)</span>

<span class="sd">    Return the relative photopic luminosity function for the wavelengths in</span>
<span class="sd">    :math:`\lambda` [m]. If :math:`\lambda` is an array then the result is a</span>
<span class="sd">    vector whose elements are the luminosity at the corresponding</span>
<span class="sd">    :math:`\lambda`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import rluminos</span>
<span class="sd">        &gt;&gt;&gt; rluminos(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; rluminos([550e-9, 600e-9])</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Relative luminosity lies in the interval 0 to 1, which indicate the</span>
<span class="sd">          intensity with which wavelengths are perceived by the light-adapted</span>
<span class="sd">          human eye.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cmfxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># photopic luminosity is the Y color matching function</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="ccxyz">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.ccxyz">[docs]</a>
<span class="k">def</span> <span class="nf">ccxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    xyz chromaticity coordinates</span>

<span class="sd">    :param λ: wavelength 𝜆 [m]</span>
<span class="sd">    :type λ: float, array_like(N)</span>
<span class="sd">    :param e: illlumination spectrum defined at the wavelengths 𝜆 (optional)</span>
<span class="sd">    :type e: array_like(N), optional</span>
<span class="sd">    :return: xyz-chromaticity coordinates</span>
<span class="sd">    :rtype: ndarray(3), ndarray(N,3)</span>

<span class="sd">    Compute the xyz-chromaticity coordinates for illumination at the specific</span>
<span class="sd">    wavelength :math:`\lambda` [m]. If :math:`\lambda` is an array, then the</span>
<span class="sd">    result is an where the rows are the chromaticity coordinates at the</span>
<span class="sd">    corresponding elements of :math:`\lambda`.</span>

<span class="sd">    If ``e`` is given, compute the xyz-chromaticity coordinates for an</span>
<span class="sd">    illumination spectrum :math:`\texttt{e}(\lambda)` defined at corresponding</span>
<span class="sd">    wavelengths of :math:`\lambda`. This is the tristimulus that has the same</span>
<span class="sd">    visual sensation as :math:`\texttt{e}(\lambda)`.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import ccxyz, loadspectrum</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; ccxyz(550e-9)</span>
<span class="sd">        &gt;&gt;&gt; ccxyz([550e-9, 600e-9])</span>
<span class="sd">        &gt;&gt;&gt; l = np.linspace(380, 700, 10) * 1e-9  # visible spectrum</span>
<span class="sd">        &gt;&gt;&gt; e = loadspectrum(l, &quot;solar&quot;)</span>
<span class="sd">        &gt;&gt;&gt; lambda2rg(l, e)</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`cmfxyz` :func:`lambda2xy`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">λ</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">cmfxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">cc</span></div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<span class="k">def</span> <span class="nf">_loadrgbdict</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load file as rgb dictionary</span>

<span class="sd">    :param fname: filename</span>
<span class="sd">    :type fname: string</span>
<span class="sd">    :return: rgbdict</span>
<span class="sd">    :rtype: dictionary</span>

<span class="sd">    ``_loadrgbdict(fname)`` returns ``rgbdict`` from ``fname``, otherwise</span>
<span class="sd">    returns Empty</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Assumes the file is organized as four columns: R, G, B, name.</span>
<span class="sd">        - Color names are converted to lower case</span>
<span class="sd">        - # comment lines and blank lines are ignored</span>
<span class="sd">        - Values in the range [0,255] are mapped to [0,1.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;file name must be a string&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">_loaddata</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>

    <span class="c1"># result is an ndarray of tuples</span>
    <span class="c1"># convert data to a dictionary</span>
    <span class="n">rgbdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="o">*</span><span class="n">rgb</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">rgbdict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="mf">255.0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rgb</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rgbdict</span>


<span class="n">_rgbdict</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">color_bgr</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">rgb</span> <span class="o">=</span> <span class="n">name2color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">rgb</span><span class="p">)]</span>


<div class="viewcode-block" id="name2color">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.name2color">[docs]</a>
<span class="k">def</span> <span class="nf">name2color</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">colorspace</span><span class="o">=</span><span class="s2">&quot;RGB&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map color name to value</span>

<span class="sd">    :param name: name of a color</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param colorspace: name of colorspace, one of: ``&#39;rgb&#39;`` [default], ``&#39;xyz&#39;``, ``&#39;xy&#39;``, ``&#39;ab&#39;``</span>
<span class="sd">    :type colorspace: str, optional</span>
<span class="sd">    :param dtype: datatype of returned numeric values</span>
<span class="sd">    :type: str</span>
<span class="sd">    :return: color tristimulus or chromaticity value</span>
<span class="sd">    :rtype: ndarray(3), ndarray(2)</span>

<span class="sd">    Looks up the RGB tristimulus for this color using ``matplotlib.colors`` and</span>
<span class="sd">    converts it to the desired ``colorspace``.</span>

<span class="sd">    RGB tristimulus values are in the range [0,1].  If ``dtype`` is specified,</span>
<span class="sd">    the values are scaled to the range [0,M] where M is the maximum positive</span>
<span class="sd">    value of ``dtype`` and cast to type ``dtype``.</span>

<span class="sd">    Colors can have long names like ``&#39;red&#39;`` or ``&#39;sky blue&#39;`` as well as single character</span>
<span class="sd">    names like ``&#39;r&#39;``, ``&#39;g&#39;``, ``&#39;b&#39;``, ``&#39;c&#39;``, ``&#39;m&#39;``, ``&#39;y&#39;``, ``&#39;w&#39;``, ``&#39;k&#39;``.</span>

<span class="sd">    If a Python-style regexp is passed, then the return value is a list</span>
<span class="sd">    of matching color names.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import name2color</span>
<span class="sd">        &gt;&gt;&gt; name2color(&#39;r&#39;)</span>
<span class="sd">        &gt;&gt;&gt; name2color(&#39;r&#39;, dtype=&#39;uint8&#39;)</span>
<span class="sd">        &gt;&gt;&gt; name2color(&#39;r&#39;, &#39;xy&#39;)</span>
<span class="sd">        &gt;&gt;&gt; name2color(&#39;lime green&#39;)</span>
<span class="sd">        &gt;&gt;&gt; name2color(&#39;.*burnt.*&#39;)</span>

<span class="sd">    .. note:: Uses color database from Matplotlib.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`~color2name`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colorspace</span> <span class="o">=</span> <span class="n">colorspace</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">csconvert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>

        <span class="n">rgb</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cs</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">rgb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">cs</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cs</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xyz</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cs</span> <span class="o">==</span> <span class="s2">&quot;ab&quot;</span><span class="p">:</span>
            <span class="n">Lab</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="s2">&quot;lab&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Lab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown colorspace&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">c</span> <span class="ow">in</span> <span class="s2">&quot;.?*&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">name</span><span class="p">]):</span>
        <span class="c1"># has a wildcard</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">,</span>
                <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">colors</span><span class="o">.</span><span class="n">get_named_colors_mapping</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()],</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">csconvert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">colorspace</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">color</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">color</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="color2name">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.color2name">[docs]</a>
<span class="k">def</span> <span class="nf">color2name</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">colorspace</span><span class="o">=</span><span class="s2">&quot;RGB&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map color value to color name</span>

<span class="sd">    :param color: color value</span>
<span class="sd">    :type color: array_like(3), array_like(2)</span>
<span class="sd">    :param colorspace: name of colorspace, one of: ``&#39;rgb&#39;`` [default], ``&#39;xyz&#39;``, ``&#39;xy&#39;``, ``&#39;ab&#39;``</span>
<span class="sd">    :type colorspace: str, optional</span>
<span class="sd">    :return: color name</span>
<span class="sd">    :rtype: str</span>

<span class="sd">    Converts the given value from the specified ``colorspace`` to RGB and finds</span>
<span class="sd">    the closest (Euclidean distance) value in ``matplotlib.colors``.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import color2name</span>
<span class="sd">        &gt;&gt;&gt; color2name(([0 ,0, 1]))</span>
<span class="sd">        &gt;&gt;&gt; color2name((0.2, 0.3), &#39;xy&#39;)</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Color name may contain a wildcard, eg. &quot;?burnt&quot;</span>
<span class="sd">        - Uses color database from Matplotlib</span>
<span class="sd">        - Tristiumuls values are [0,1]</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`~name2color`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># map numeric tuple to color name</span>
    <span class="n">colorspace</span> <span class="o">=</span> <span class="n">colorspace</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># convert tuple or list into np array</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
        <span class="p">[</span><span class="n">colors</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="o">.</span><span class="n">get_named_colors_mapping</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;color value must have 3 elements&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;lab&quot;</span><span class="p">):</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="n">colorspace</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">table</span> <span class="o">-</span> <span class="n">color</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">get_named_colors_mapping</span><span class="p">())[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;a*b*&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;color value must have 2 elements&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colorspace</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;a*b*&quot;</span><span class="p">):</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">,</span> <span class="s2">&quot;Lab&quot;</span><span class="p">)</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">table</span> <span class="o">-</span> <span class="n">color</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">get_named_colors_mapping</span><span class="p">())[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown colorspace&quot;</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">colorname</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">colorspace</span><span class="o">=</span><span class="s2">&quot;RGB&quot;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s2">&quot;please use name2color or color2name&quot;</span><span class="p">)</span>


<span class="c1"># ------------------------------------------------------------------------- #</span>

<span class="n">_white</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;d65&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3127</span><span class="p">,</span> <span class="mf">0.3290</span><span class="p">],</span> <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.33333</span><span class="p">,</span> <span class="mf">0.33333</span><span class="p">]}</span>  <span class="c1"># D65 2 deg  # E</span>

<span class="n">_xy_primaries</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;itu-709&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.64</span><span class="p">,</span> <span class="mf">0.33</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.30</span><span class="p">,</span> <span class="mf">0.60</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.06</span><span class="p">]]),</span>
    <span class="s2">&quot;cie&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.6400</span><span class="p">,</span> <span class="mf">0.3300</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3000</span><span class="p">,</span> <span class="mf">0.6000</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1500</span><span class="p">,</span> <span class="mf">0.0600</span><span class="p">]]),</span>
    <span class="s2">&quot;srgb&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.6400</span><span class="p">,</span> <span class="mf">0.3300</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3000</span><span class="p">,</span> <span class="mf">0.6000</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1500</span><span class="p">,</span> <span class="mf">0.0600</span><span class="p">]]),</span>
<span class="p">}</span>


<div class="viewcode-block" id="XYZ2RGBxform">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.XYZ2RGBxform">[docs]</a>
<span class="k">def</span> <span class="nf">XYZ2RGBxform</span><span class="p">(</span><span class="n">white</span><span class="o">=</span><span class="s2">&quot;D65&quot;</span><span class="p">,</span> <span class="n">primaries</span><span class="o">=</span><span class="s2">&quot;sRGB&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transformation matrix from XYZ to RGB colorspace</span>

<span class="sd">    :param white: illuminant: &#39;E&#39; or &#39;D65&#39; [default]</span>
<span class="sd">    :type white: str, optional</span>
<span class="sd">    :param primaries: xy coordinates of primaries to use: ``&#39;CIE&#39;``, ``&#39;ITU=709&#39;`` or</span>
<span class="sd">        ``&#39;sRGB&#39;`` [default]</span>
<span class="sd">    :type primaries: str, optional</span>
<span class="sd">    :raises ValueError: bad white point, bad primaries</span>
<span class="sd">    :return: transformation matrix</span>
<span class="sd">    :rtype: ndarray(3,3)</span>

<span class="sd">    Return a :math:`3 \times 3` matrix that transforms an XYZ tristimulus value</span>
<span class="sd">    to an RGB tristimulus value.  The transformation applies to linear, non</span>
<span class="sd">    gamma encoded, tristimulus values.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import XYZ2RGBxform</span>
<span class="sd">        &gt;&gt;&gt; XYZ2RGBxform()</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Use the inverse of the transform for RGB to XYZ.</span>
<span class="sd">        - Works with linear RGB colorspace, not gamma encoded</span>

<span class="sd">    :seealso: :func:`gamma_decode`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">white</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">white</span> <span class="o">=</span> <span class="n">_white</span><span class="p">[</span><span class="n">white</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;unknown white value, must be one of&quot;</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_white</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">white</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">white</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">primaries</span> <span class="o">=</span> <span class="n">_xy_primaries</span><span class="p">[</span><span class="n">primaries</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;unknown primary value, must be one of&quot;</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_xy_primaries</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">white</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">primaries</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">primaries</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">primaries</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">primaries</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">primaries</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">primaries</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># build the columns of the inverse transform</span>
    <span class="n">Xr</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Xg</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Xb</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="n">primaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xr</span><span class="p">,</span> <span class="n">Xg</span><span class="p">,</span> <span class="n">Xb</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># determine the white point</span>
    <span class="n">Xw</span> <span class="o">=</span> <span class="n">column</span><span class="p">(</span><span class="n">white</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">@</span> <span class="n">Xw</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Xr</span><span class="p">,</span> <span class="n">Xg</span><span class="p">,</span> <span class="n">Xb</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span></div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<span class="k">def</span> <span class="nf">_xy_chromaticity_diagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">ex</span> <span class="o">=</span> <span class="mf">0.8</span>
    <span class="n">ey</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="n">e0</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">ex</span> <span class="o">-</span> <span class="n">e0</span><span class="p">))</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">ey</span> <span class="o">-</span> <span class="n">e0</span><span class="p">))</span>
    <span class="c1"># generate colors in xyY color space</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">Nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
    <span class="c1"># hack to prevent divide by zero errors</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="c1"># convert xyY to XYZ</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span> <span class="o">*</span> <span class="n">Y</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span>
    <span class="n">XYZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">RGB</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">XYZ</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">)</span>
    <span class="n">RGB</span> <span class="o">=</span> <span class="n">_normalize</span><span class="p">(</span><span class="n">RGB</span><span class="p">)</span>  <span class="c1"># fit to interval [0, 1]</span>
    <span class="n">RGB</span> <span class="o">=</span> <span class="n">gamma_encode</span><span class="p">(</span><span class="n">RGB</span><span class="p">)</span>  <span class="c1"># gamma encode</span>

    <span class="c1"># define the spectral locus boundary as xy points, Mx2 matrix</span>
    <span class="n">nm</span> <span class="o">=</span> <span class="mf">1e-9</span>
    <span class="n">λ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">700</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">nm</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">ccxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
    <span class="n">xy_locus</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1">## make a smooth boundary with spline interpolation</span>

    <span class="c1"># set up interpolators for x and y</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">xy_locus</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">drange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">fxi</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">drange</span><span class="p">,</span> <span class="n">xy_locus</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
    <span class="n">fyi</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">drange</span><span class="p">,</span> <span class="n">xy_locus</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>

    <span class="c1"># interpolate in steps of 0.1</span>
    <span class="n">irange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">fxi</span><span class="p">(</span><span class="n">irange</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">fyi</span><span class="p">(</span><span class="n">irange</span><span class="p">)</span>

    <span class="c1"># close the path</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">yi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">## determine which points from xx, yy, are contained within polygon</span>
    <span class="c1">## defined by xi, yi</span>

    <span class="c1"># create a polygon</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">polypath</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># flatten x/y grids into array columnwise</span>
    <span class="n">xc</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="n">yc</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="c1"># check if these xy points are contained in the polygon</span>
    <span class="c1"># returns a bool array</span>
    <span class="n">pts_in</span> <span class="o">=</span> <span class="n">polypath</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># reshape it to size of original grids</span>
    <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">~</span><span class="n">pts_in</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>

    <span class="c1"># set outside pixels to white</span>
    <span class="n">outside3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">outside</span><span class="p">,</span> <span class="n">outside</span><span class="p">,</span> <span class="n">outside</span><span class="p">))</span>
    <span class="n">RGB</span><span class="p">[</span><span class="n">outside3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">RGB</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># flip top to bottom</span>


<span class="k">def</span> <span class="nf">_ab_chromaticity_diagram</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

    <span class="c1"># convert from Lab to RGB</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span>
    <span class="n">Lab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">RGB</span> <span class="o">=</span> <span class="n">colorspace_convert</span><span class="p">(</span><span class="n">Lab</span><span class="p">,</span> <span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb&quot;</span><span class="p">)</span>
    <span class="c1"># this exactly matches the MATLAB function lab2rgb with default whitespace</span>
    <span class="c1"># its doco says it converts to SRGB gamma encoded RGB.</span>

    <span class="n">RGB</span> <span class="o">=</span> <span class="n">_normalize</span><span class="p">(</span><span class="n">RGB</span><span class="p">)</span>  <span class="c1"># fit to interval [0, 1]</span>

    <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">128</span>
    <span class="c1"># set outside pixels to white</span>
    <span class="n">outside3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">outside</span><span class="p">,</span> <span class="n">outside</span><span class="p">,</span> <span class="n">outside</span><span class="p">))</span>
    <span class="n">RGB</span><span class="p">[</span><span class="n">outside3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">RGB</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># flip top to bottom</span>


<div class="viewcode-block" id="plot_chromaticity_diagram">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.plot_chromaticity_diagram">[docs]</a>
<span class="k">def</span> <span class="nf">plot_chromaticity_diagram</span><span class="p">(</span>
    <span class="n">colorspace</span><span class="o">=</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display chromaticity diagram</span>

<span class="sd">    :param colorspace: colorspace to show: &#39;xy&#39; [default], &#39;lab&#39;, &#39;ab&#39;</span>
<span class="sd">    :type colorspace: string</span>
<span class="sd">    :param brightness: for xy this is Y, for ab this is L, defaults to 1</span>
<span class="sd">    :type brightness: float, optional</span>
<span class="sd">    :param N: number of points to sample in the x- and y-directions, defaults to 500</span>
<span class="sd">    :type N: integer, optional</span>
<span class="sd">    :param alpha: alpha value for plot in the range [0,1], defaults to 1</span>
<span class="sd">    :type alpha: float, optional</span>
<span class="sd">    :param block: block until plot is dismissed, defaults to False</span>
<span class="sd">    :type block: bool</span>
<span class="sd">    :return: chromaticity diagram as an image</span>
<span class="sd">    :rtype: ndarray(N,N,3)</span>

<span class="sd">    Display, using Matplotlib, a chromaticity diagram as an image using</span>
<span class="sd">    Matplotlib.  This is the &quot;horseshoe-shaped&quot; curve bounded by the spectral</span>
<span class="sd">    locus, and internal pixels are an approximation of their true color (at the</span>
<span class="sd">    specified ``brightness``).</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import plot_chromaticity_diagram</span>
<span class="sd">        &gt;&gt;&gt; plot_chromaticity_diagram()  # show filled chromaticity diagram</span>

<span class="sd">    .. plot::</span>

<span class="sd">        from machinevisiontoolbox import plot_chromaticity_diagram</span>
<span class="sd">        plot_chromaticity_diagram()</span>

<span class="sd">    .. note:: The colors shown within the locus only approximate the true</span>
<span class="sd">            colors, due to the gamut of the display device.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`plot_spectral_locus`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">colorspace</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
        <span class="n">CS</span> <span class="o">=</span> <span class="n">_xy_chromaticity_diagram</span><span class="p">(</span><span class="n">Y</span><span class="o">=</span><span class="n">brightness</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">colorspace</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;a*b*&quot;</span><span class="p">):</span>
        <span class="n">CS</span> <span class="o">=</span> <span class="n">_ab_chromaticity_diagram</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">brightness</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">CS</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">127</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;a*&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;b*&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad colorspace&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">isinteractive</span><span class="p">()</span> <span class="ow">and</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;plt.show&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CS</span></div>



<div class="viewcode-block" id="plot_spectral_locus">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.plot_spectral_locus">[docs]</a>
<span class="k">def</span> <span class="nf">plot_spectral_locus</span><span class="p">(</span>
    <span class="n">colorspace</span><span class="o">=</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lambda_ticks</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot spectral locus</span>

<span class="sd">    :param colorspace: the color space: &#39;xy&#39; [default] or &#39;rg&#39;</span>
<span class="sd">    :type colorspace: str, optional</span>
<span class="sd">    :param labels: display wavelength labels, defaults to True</span>
<span class="sd">    :type labels: bool, optional</span>
<span class="sd">    :param ax: Matplotlib axes to draw into, defaults to current</span>
<span class="sd">    :type ax: axes, optional</span>
<span class="sd">    :param block: block until plot is dismissed, defaults to False</span>
<span class="sd">    :type block: bool, optional</span>
<span class="sd">    :param lambda_ticks: interval between wavelength labels, defaults to None</span>
<span class="sd">    :type lambda_ticks: array_like, optional</span>
<span class="sd">    :raises ValueError: unknown `colorspace`</span>

<span class="sd">    Plot, using Matplotlib, the boundary of the &quot;horseshoe&quot; in the chromaticity</span>
<span class="sd">    diagram which represents pure spectral colors.  Labelled points are added to</span>
<span class="sd">    the boundary at default spacing, but :math:`\lambda` values can be specified</span>
<span class="sd">    by the iterable ``lambda_ticks``.</span>

<span class="sd">    Typically, would be used in conjunction with :func:`plot_chromaticity_diagram`</span>
<span class="sd">    to plot chromaticity diagram with labelled boundary.</span>

<span class="sd">    Example::</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import plot_spectral_locus</span>
<span class="sd">        &gt;&gt;&gt; plot_spectral_locus()  # add the border</span>

<span class="sd">    .. plot::</span>

<span class="sd">        from machinevisiontoolbox import plot_spectral_locus</span>
<span class="sd">        plot_spectral_locus()</span>

<span class="sd">    :seealso: :func:`plot_chromaticity_diagram`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nm</span> <span class="o">=</span> <span class="mf">1e-9</span>

    <span class="n">λ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">700</span><span class="p">)</span> <span class="o">*</span> <span class="n">nm</span>

    <span class="k">if</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;xy&quot;</span><span class="p">):</span>
        <span class="n">locus</span> <span class="o">=</span> <span class="n">ccxyz</span><span class="p">(</span><span class="n">λ</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rg&quot;</span><span class="p">):</span>
        <span class="n">locus</span> <span class="o">=</span> <span class="n">lambda2rg</span><span class="p">(</span><span class="n">λ</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">locus</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">locus</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
        <span class="c1">## add ticks</span>

        <span class="c1"># well-spaced points around the locus</span>
        <span class="k">if</span> <span class="n">lambda_ticks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">λ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">460</span><span class="p">,</span> <span class="mi">550</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">λ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">λ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">560</span><span class="p">,</span> <span class="mi">620</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">λ</span> <span class="o">=</span> <span class="n">lambda_ticks</span>

        <span class="k">if</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;xy&quot;</span><span class="p">):</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">cmfxyz</span><span class="p">(</span><span class="n">λ</span> <span class="o">*</span> <span class="mf">1e-9</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">colorspace</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rg&quot;</span><span class="p">,):</span>
            <span class="n">rgb</span> <span class="o">=</span> <span class="n">cmfrgb</span><span class="p">(</span><span class="n">λ</span> <span class="o">*</span> <span class="mf">1e-9</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad colorspace&quot;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;ko&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">λ</span><span class="p">)):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;  </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">λ</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">plt</span><span class="o">.</span><span class="n">isinteractive</span><span class="p">()</span> <span class="ow">and</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;plt.show&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span></div>



<div class="viewcode-block" id="cie_primaries">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.cie_primaries">[docs]</a>
<span class="k">def</span> <span class="nf">cie_primaries</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CIE primary wavelengths</span>

<span class="sd">    ``cie_primaries`` is a 3-vector with the wavelengths [m] of the</span>
<span class="sd">    CIE-1976 red, green and blue primaries respectively.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import cie_primaries</span>
<span class="sd">        &gt;&gt;&gt; cie_primaries()*1e9</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">700</span><span class="p">,</span> <span class="mf">546.1</span><span class="p">,</span> <span class="mf">435.8</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e-9</span></div>



<span class="c1"># ------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="colorspace_convert">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.colorspace_convert">[docs]</a>
<span class="k">def</span> <span class="nf">colorspace_convert</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert images between colorspaces</span>

<span class="sd">    :param image: input image</span>
<span class="sd">    :type image: ndarray(H,W,3), (N,3)</span>
<span class="sd">    :param src: input colorspace name</span>
<span class="sd">    :type src: str</span>
<span class="sd">    :param dst: output colorspace name</span>
<span class="sd">    :type dst: str</span>
<span class="sd">    :return: output image</span>
<span class="sd">    :rtype: ndarray(N,M,3), (N,3)</span>

<span class="sd">    Convert images or rowwise color coordinates from one color space to another.</span>
<span class="sd">    The work is done by OpenCV and assumes that the input image is linear, not</span>
<span class="sd">    gamma encoded, and the result is also linear.</span>

<span class="sd">    Color space names (synonyms listed on the same line) are:</span>

<span class="sd">    =======================     ========================</span>
<span class="sd">    Color space name            Option string(s)</span>
<span class="sd">    =======================     ========================</span>
<span class="sd">    grey scale                  ``&#39;grey&#39;``, ``&#39;gray&#39;``</span>
<span class="sd">    RGB (red/green/blue)        ``&#39;rgb&#39;``</span>
<span class="sd">    BGR (blue/green/red)        ``&#39;bgr&#39;``</span>
<span class="sd">    CIE XYZ                     ``&#39;xyz&#39;``, ``&#39;xyz_709&#39;``</span>
<span class="sd">    YCrCb                       ``&#39;ycrcb&#39;``</span>
<span class="sd">    HSV (hue/sat/value)         ``&#39;hsv&#39;``</span>
<span class="sd">    HLS (hue/lightness/sat)     ``&#39;hls&#39;``</span>
<span class="sd">    CIE L*a*b*                  ``&#39;lab&#39;``, &#39;``l*a*b*&#39;``</span>
<span class="sd">    CIE L*u*v*                  ``&#39;luv&#39;``, ``&#39;l*u*v*&#39;``</span>
<span class="sd">    =======================     ========================</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">        &gt;&gt;&gt; from machinevisiontoolbox import colorspace_convert</span>
<span class="sd">        &gt;&gt;&gt; colorspace_convert([0, 0, 1], &#39;rgb&#39;, &#39;hls&#39;)</span>

<span class="sd">    :seealso: :func:`gamma_decode` `cv2.cvtColor &lt;https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">operation</span> <span class="o">=</span> <span class="n">_convertflag</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># its a color image</span>
        <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="n">operation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># not an image, see if it&#39;s Nx3</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="n">operation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">converted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converted</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converted</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_convertflag</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>

    <span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">dst</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">src</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="s2">&quot;gray&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2GRAY</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz_709&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2XYZ</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;ycrcb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2YCrCb</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;hsv&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2HSV</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;hls&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2HLS</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2Lab</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;luv&quot;</span><span class="p">,</span> <span class="s2">&quot;l*u*v*&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_RGB2Luv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;destination colorspace </span><span class="si">{</span><span class="n">dst</span><span class="si">}</span><span class="s2"> not known&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="s2">&quot;gray&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz_709&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2XYZ</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;ycrcb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2YCrCb</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;hsv&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2HSV</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;hls&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2HLS</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2Lab</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;luv&quot;</span><span class="p">,</span> <span class="s2">&quot;l*u*v*&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2Luv</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz_709&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_XYZ2RGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_XYZ2BGR</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="s2">&quot;ycrcb&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_YCrCb2RGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_YCrCbBGR</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="s2">&quot;hsv&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_HSVRGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_HSV2BGR</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="o">==</span> <span class="s2">&quot;hls&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_HLS2RGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_HLS2BGR</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lab&quot;</span><span class="p">,</span> <span class="s2">&quot;l*a*b*&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_Lab2RGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_Lab2BGR</span>

    <span class="k">elif</span> <span class="n">src</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;luv&quot;</span><span class="p">,</span> <span class="s2">&quot;l*u*v*&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_Luv2RGB</span>
        <span class="k">elif</span> <span class="n">dst</span> <span class="o">==</span> <span class="s2">&quot;bgr&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_Luv2BGR</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown conversion </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">dst</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># ------------------------------------------------------------------------- #</span>


<div class="viewcode-block" id="gamma_encode">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.gamma_encode">[docs]</a>
<span class="k">def</span> <span class="nf">gamma_encode</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="s2">&quot;sRGB&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gamma encoding</span>

<span class="sd">    :param image: input image</span>
<span class="sd">    :type image: ndarray(H,W), ndarray(H,W,N)</span>
<span class="sd">    :param gamma: gamma exponent or &quot;srgb&quot;</span>
<span class="sd">    :type gamma: float, str</span>
<span class="sd">    :return: gamma encoded version of image</span>
<span class="sd">    :rtype: ndarray(H,W), ndarray(H,W,N)</span>

<span class="sd">    Maps linear tristimulus values to a gamma encoded values using either:</span>

<span class="sd">    - :math:`y = x^\gamma`</span>
<span class="sd">    - the sRGB mapping which is an exponential as above, with a linear segment</span>
<span class="sd">      near zero.</span>

<span class="sd">    .. note::</span>
<span class="sd">        - Gamma encoding should be applied to any image prior to display, since</span>
<span class="sd">          the display assumes the image is gamma encoded.  If not encoded, the</span>
<span class="sd">          displayed image will appear very contrasty.</span>
<span class="sd">        - Gamma encoding is typically performed in a camera with</span>
<span class="sd">          :math:`\gamma=0.45`.</span>
<span class="sd">        - For images with multiple planes, the gamma encoding is applied</span>
<span class="sd">          to each plane.</span>
<span class="sd">        - For images of type double, the pixels are assumed to be in the</span>
<span class="sd">          range 0 to 1.</span>
<span class="sd">        - For images of type int, the pixels are assumed in the range 0 to</span>
<span class="sd">          the maximum value of their class.  Pixels are converted first to</span>
<span class="sd">          double, encoded, then converted back to the integer class.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`gamma_decode` :func:`colorspace_convert`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gamma must be string or scalar&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;srgb&quot;</span><span class="p">:</span>

        <span class="n">imagef</span> <span class="o">=</span> <span class="n">float_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># greyscale</span>
            <span class="k">return</span> <span class="n">_srgb</span><span class="p">(</span><span class="n">imagef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># multi-dimensional</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">imagef</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imagef</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_srgb</span><span class="p">(</span><span class="n">imagef</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">p</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting 2d or 3d image&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="c1"># original image was float, convert back</span>
            <span class="k">return</span> <span class="n">int_image</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># normal power law:</span>
        <span class="c1"># import code</span>
        <span class="c1"># code.interact(local=dict(globals(), **locals()))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">**</span><span class="n">gamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># int image</span>
            <span class="n">maxg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxg</span><span class="p">)</span> <span class="o">**</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxg</span></div>



<div class="viewcode-block" id="gamma_decode">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.gamma_decode">[docs]</a>
<span class="k">def</span> <span class="nf">gamma_decode</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="s2">&quot;sRGB&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gamma decoding</span>

<span class="sd">    :param image: input image</span>
<span class="sd">    :type image: ndarray(H,W), ndarray(H,W,N)</span>
<span class="sd">    :param gamma: gamma exponent or &quot;srgb&quot;</span>
<span class="sd">    :type gamma: float, str</span>
<span class="sd">    :return: gamma decoded version of image</span>
<span class="sd">    :rtype: ndarray(H,W), ndarray(H,W,N)</span>

<span class="sd">    Maps linear tristimulus values to a gamma encoded values using either:</span>

<span class="sd">    - :math:`y = x^\gamma`</span>
<span class="sd">    - the sRGB mapping which is an exponential as above, with a linear segment</span>
<span class="sd">      near zero.</span>

<span class="sd">    .. note::</span>
<span class="sd">        - Gamma decoding should be applied to any color image prior to</span>
<span class="sd">          colometric operations.</span>
<span class="sd">        - Gamma decoding is typically performed in the display with</span>
<span class="sd">          :math:`\gamma=2.2`.</span>
<span class="sd">        - For images with multiple planes, the gamma correction is applied</span>
<span class="sd">          to each plane.</span>
<span class="sd">        - For images of type double, the pixels are assumed to be in the</span>
<span class="sd">          range 0 to 1.</span>
<span class="sd">        - For images of type int, the pixels are assumed in the range 0 to</span>
<span class="sd">          the maximum value of their class.  Pixels are converted first to</span>
<span class="sd">          double, encoded, then converted back to the integer class.</span>

<span class="sd">    :references:</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>

<span class="sd">    :seealso: :func:`gamma_encode`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gamma must be string or scalar&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gamma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;srgb&quot;</span><span class="p">:</span>

        <span class="n">imagef</span> <span class="o">=</span> <span class="n">float_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># greyscale</span>
            <span class="k">return</span> <span class="n">_srgb_inverse</span><span class="p">(</span><span class="n">imagef</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># multi-dimensional</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">imagef</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">imagef</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imagef</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_srgb_inverse</span><span class="p">(</span><span class="n">imagef</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">p</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expecting 2d or 3d image&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="c1"># original image was integer, convert back</span>
            <span class="k">return</span> <span class="n">int_image</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># normal power law:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">**</span><span class="n">gamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># int image</span>
            <span class="n">maxg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="n">maxg</span><span class="p">)</span> <span class="o">**</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">maxg</span>  <span class="c1"># original</span></div>

            <span class="c1"># return ((image.astype(np.float32) / maxg) ** gamma) * maxg</span>


<span class="k">def</span> <span class="nf">_srgb_inverse</span><span class="p">(</span><span class="n">Rg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse sRGB gamma correction</span>

<span class="sd">    :param Rg: 2D image</span>
<span class="sd">    :type Rg: numpy array, shape (N,M)</span>
<span class="sd">    :return: R</span>
<span class="sd">    :rtype: numpy array</span>

<span class="sd">    - ``_srgb_imverse(Rg)`` maps an sRGB gamma encoded image to linear</span>
<span class="sd">        tristimulus values.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Based on code from Pascal Getreuer 2005-2010</span>
<span class="sd">        - And colorspace.m from Peter Corke&#39;s Machine Vision Toolbox</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Rg</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">Rg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">Rg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0404482362771076</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Rg</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">noti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Rg</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mf">12.92</span>
    <span class="n">R</span><span class="p">[</span><span class="n">noti</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">Rg</span><span class="p">[</span><span class="n">noti</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.055</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.055</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.4</span>
    <span class="k">return</span> <span class="n">R</span>


<span class="k">def</span> <span class="nf">_srgb</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sRGB Gamma correction</span>

<span class="sd">    :param R: 2D image</span>
<span class="sd">    :type R: numpy array, shape (N,M)</span>
<span class="sd">    :return: Rg</span>
<span class="sd">    :rtype: numpy array</span>

<span class="sd">    - ``_srgb(R)`` maps linear tristimulus values to an sRGB gamma encoded</span>
<span class="sd">        image.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. runblock:: pycon</span>

<span class="sd">    .. note::</span>

<span class="sd">        - Based on code from Pascal Getreuer 2005-2010</span>
<span class="sd">        - And colorspace.m from Peter Corke&#39;s Machine Vision Toolbox</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Rg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">0.0031306684425005883</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">0.416666666666666667</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">noti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">R</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">Rg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mf">12.92</span>
    <span class="n">Rg</span><span class="p">[</span><span class="n">noti</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mf">1.055</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">noti</span><span class="p">]</span> <span class="o">**</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.055</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Rg</span>


<span class="c1"># ------------------------------------------------------------------------- #</span>


<span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="n">rgb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the pixel values</span>

<span class="sd">    :param rgb: [description]</span>
<span class="sd">    :type rgb: [type]</span>

<span class="sd">    Normalize pixel values into the range [0, 1].  After colorspace transformations</span>
<span class="sd">    pixel values can be outside this interval, both negative and positive.</span>

<span class="sd">    For every pixel (r, g, b):</span>

<span class="sd">    - If ``w = min(r, g, b)`` &lt; 0 we must add (w, w, w) to make a displayable</span>
<span class="sd">      value.  This corresponds to adding some amount of white which will desaturate the color.</span>
<span class="sd">      ``r&#39; = r + w, g&#39; = g + w, b&#39; = b + w``.</span>
<span class="sd">    - If ``s = max(r&#39;, g&#39;, b&#39;)`` &gt; 1 we must scale the value by ``s`` to make it</span>
<span class="sd">      displayable: ``r&#39;&#39; = r&#39; / s, g&#39;&#39; = g&#39; / s, b&#39;&#39; = b&#39; / s``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># find minimum of (r, g, b, 0)</span>
    <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># and substract, effectively blending it with white (desaturation)</span>
    <span class="n">rgb</span> <span class="o">=</span> <span class="n">rgb</span> <span class="o">-</span> <span class="n">mn</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># find maximum of (r, g, b, 1)</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># and scale the pixel</span>
    <span class="n">rgb</span> <span class="o">=</span> <span class="n">rgb</span> <span class="o">/</span> <span class="n">mx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rgb</span>


<div class="viewcode-block" id="shadow_invariant">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.shadow_invariant">[docs]</a>
<span class="k">def</span> <span class="nf">shadow_invariant</span><span class="p">(</span>
    <span class="n">image</span><span class="p">,</span> <span class="n">θ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometricmean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sharpen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">primaries</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shadow invariant image</span>

<span class="sd">    :param image: linear color image</span>
<span class="sd">    :type image: ndarray(H,W,3) float</span>
<span class="sd">    :param geometricmean: normalized with geometric mean of color channels, defaults to True</span>
<span class="sd">    :type geometricmean: bool, optional</span>
<span class="sd">    :param exp: exponentiate the logarithmic image, defaults to False</span>
<span class="sd">    :type exp: bool, optional</span>
<span class="sd">    :param sharpen: a sharpening transform, defaults to None</span>
<span class="sd">    :type sharpen: ndarray(3,3), optional</span>
<span class="sd">    :param primaries: camera peak filter responses (nm), defaults to None</span>
<span class="sd">    :type primaries: array_like(3), optional</span>
<span class="sd">    :return: greyscale shadow invariant image</span>
<span class="sd">    :rtype: ndarray(H,W)</span>

<span class="sd">    Computes the greyscale invariant image computed from the passed color image</span>
<span class="sd">    with a projection line of slope ``θ``.</span>

<span class="sd">    If ``θ`` is not provided then the slope is computed from the camera spectral</span>
<span class="sd">    characteristics ``primaries`` a vector of the peak response of the camera&#39;s</span>
<span class="sd">    filters in the order red, green, blue.  If these aren&#39;t provided they</span>
<span class="sd">    default to 610, 538, and 460nm.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; im = iread(&#39;parks.png&#39;, gamma=&#39;sRGB&#39;, dtype=&#39;double&#39;)</span>
<span class="sd">        &gt;&gt;&gt; gs = shadow_invariant(im, 0.7)</span>
<span class="sd">        &gt;&gt;&gt; idisp(gs)</span>

<span class="sd">    .. note::</span>
<span class="sd">        - The input image is assumed to be linear, that is, it has been</span>
<span class="sd">          gamma decoded.</span>

<span class="sd">    :references:</span>
<span class="sd">        - “Dealing with shadows: Capturing intrinsic scene appear for image-based outdoor localisation,”</span>
<span class="sd">          P. Corke, R. Paul, W. Churchill, and P. Newman</span>
<span class="sd">          Proc. Int. Conf. Intelligent Robots and Systems (IROS), pp. 2085–2 2013.</span>
<span class="sd">        - Robotics, Vision &amp; Control for Python, Section 10.1, P. Corke, Springer 2023.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert the image into a vector (h*w,channel)</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must pass an RGB image&quot;</span><span class="p">)</span>

    <span class="c1"># compute chromaticity</span>

    <span class="k">if</span> <span class="n">sharpen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span> <span class="o">@</span> <span class="n">opt</span><span class="o">.</span><span class="n">sharpen</span>
        <span class="n">im</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">geometricmean</span><span class="p">:</span>
        <span class="c1"># denom = prod(im, 2).^(1/3);</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># this next bit will generate divide by zero errors, suppress any</span>
    <span class="c1"># error messages. The results will be nan which we can deal with later.</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">r_r</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom</span>
        <span class="n">r_b</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="c1"># Take the log</span>
    <span class="n">r_rp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">r_r</span><span class="p">)</span>
    <span class="n">r_bp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">r_b</span><span class="p">)</span>

    <span class="c1"># figure the illumination invariant direction shape=(2,)</span>

    <span class="c1"># create an array of logs (2,N)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r_rp</span><span class="p">,</span> <span class="n">r_bp</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">θ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># compute direction from the spectral peaks of the camera filters</span>
        <span class="k">if</span> <span class="n">primaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Planckian illumination constant</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="mf">1.4388e-2</span>

            <span class="c1">#  spectral peaks of the Sony ICX204 sensor used in BB2 camera</span>
            <span class="n">primaries</span> <span class="o">=</span> <span class="p">[</span><span class="mi">610</span><span class="p">,</span> <span class="mi">538</span><span class="p">,</span> <span class="mi">460</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-9</span>

            <span class="n">e_r</span> <span class="o">=</span> <span class="o">-</span><span class="n">c2</span> <span class="o">/</span> <span class="n">primaries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e_b</span> <span class="o">=</span> <span class="o">-</span><span class="n">c2</span> <span class="o">/</span> <span class="n">primaries</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">e_b</span><span class="p">,</span> <span class="o">-</span><span class="n">e_r</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># otherwise use the provided angle</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">θ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)])</span>

    <span class="n">gs</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">c</span>

    <span class="c1"># optionally exponentiate the image</span>
    <span class="k">if</span> <span class="n">exp</span><span class="p">:</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>

    <span class="c1"># reshape the gs vector to the original image size</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">gs</span></div>



<div class="viewcode-block" id="esttheta">
<a class="viewcode-back" href="../../../func_color.html#machinevisiontoolbox.base.color.esttheta">[docs]</a>
<span class="k">def</span> <span class="nf">esttheta</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sharpen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate theta for shadow invariance</span>

<span class="sd">    :param im: input image</span>
<span class="sd">    :type im: ndarray(H,W,3)</span>
<span class="sd">    :param sharpen: a sharpening transform, defaults to None</span>
<span class="sd">    :type sharpen: ndarray(3,3), optional</span>
<span class="sd">    :return: the value of θ</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    This is an interactive procedure where the image is displayed and the user</span>
<span class="sd">    selects a region of homogeneous material (eg. grass or road) that includes</span>
<span class="sd">    areas that are directly lit by the sun and in shadow.</span>

<span class="sd">    .. note:: The user selects boundary points by clicking the mouse. After the</span>
<span class="sd">        last point, hit the Enter key and the region will be closed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pickregion</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>

        <span class="n">im</span><span class="o">.</span><span class="n">disp</span><span class="p">()</span>

        <span class="n">clicks</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ginput</span><span class="p">(</span><span class="n">n</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clicks</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>

        <span class="n">base</span><span class="o">.</span><span class="n">plot_poly</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon2</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">polygon</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">()</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inside</span>

    <span class="n">k_region</span> <span class="o">=</span> <span class="n">pickregion</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>

    <span class="n">imcol</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">column</span><span class="p">()</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">imcol</span><span class="p">[</span><span class="n">k_region</span><span class="p">,</span> <span class="p">:]</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># k = find(in);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

    <span class="kn">import</span> <span class="nn">pathlib</span>
    <span class="kn">import</span> <span class="nn">os.path</span>

    <span class="n">exec</span><span class="p">(</span>
        <span class="nb">open</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">(),</span> <span class="s2">&quot;test_color.py&quot;</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># import machinevisiontoolbox.color as color</span>

    <span class="c1"># rg = color.lambda2rg(555e-9)</span>
    <span class="c1"># print(rg)</span>

    <span class="c1"># wcc = color.tristim2cc(np.r_[1, 1, 1])</span>
    <span class="c1"># print(wcc)</span>

    <span class="c1"># import code</span>
    <span class="c1"># code.interact(local=dict(globals(), **locals()))</span>

    <span class="c1"># print(colorname(&#39;red&#39;))</span>
    <span class="c1"># img = np.float32(np.r_[0.5, 0.2, 0.1]).reshape((1,1,3))</span>
    <span class="c1"># print(img.shape)</span>
    <span class="c1"># # print(cv.cvtColor(img, cv.COLOR_RGB2HSV))</span>
    <span class="c1"># print(cv.cvtColor(img, _convertflag(&#39;rgb&#39;, &#39;hsv&#39;)))</span>
    <span class="c1"># print(colorname([0.5,0.2, 0.5]))</span>
    <span class="c1"># print(colorname([0.5,0.2], &#39;xy&#39;))</span>

    <span class="c1"># rg = lambda2rg(λ=np.array([555e-9, 666e-9]),</span>
    <span class="c1">#                          e=np.array([4, 2]))</span>

    <span class="c1"># z = colorname(&#39;chocolate&#39;, &#39;xy&#39;)</span>
    <span class="c1"># print(z)</span>
    <span class="c1"># bs = colorname(&#39;burntsienna&#39;, &#39;xy&#39;)</span>
    <span class="c1"># print(bs)</span>

    <span class="c1"># colorname(&#39;?burnt&#39;)</span>

    <span class="c1"># z = colorname(&#39;burntsienna&#39;)</span>
    <span class="c1"># print(z)</span>
    <span class="c1"># bs = colorname(&#39;burntsienna&#39;, &#39;xy&#39;)</span>
    <span class="c1"># print(bs)</span>

    <span class="c1"># green_cc = lambda2rg(500 * 1e-9)</span>
    <span class="c1"># print(green_cc)</span>

    <span class="c1"># print(name2color(&#39;r&#39;))</span>
    <span class="c1"># print(name2color(&#39;r&#39;, &#39;lab&#39;))</span>
    <span class="c1"># print(name2color(&#39;.*burnt.*&#39;))</span>
    <span class="c1"># print(color2name([0,0,1]))</span>

    <span class="c1"># nm = 1e-9;</span>
    <span class="c1"># lmbda = np.arange(300, 1_001, 10) * nm;</span>

    <span class="c1"># sun_ground = loadspectrum(lmbda, &#39;solar&#39;);</span>

    <span class="c1"># print(name2color(&#39;orange&#39;, &#39;xy&#39;))</span>
    <span class="c1"># print(name2color(&#39;.*coral.*&#39;))</span>
    <span class="c1"># print(color2name([0.45, 0.48], &#39;xy&#39;))</span>

    <span class="c1"># print(cmfrgb([500*nm, 600*nm]))</span>
    <span class="c1"># green_cc = lambda2rg(500 * nm)</span>

    <span class="c1"># pass</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke.
      <span class="lastupdated">Last updated on 08-Dec-2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>