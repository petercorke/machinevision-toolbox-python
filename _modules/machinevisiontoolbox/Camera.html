<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>machinevisiontoolbox.Camera &mdash; Machine Vision Toolbox 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Machine Vision Toolbox
            <img src="../../_static/VisionToolboxLogo_CircBlack.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../high-level.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../low-level.html">Function reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Machine Vision Toolbox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>machinevisiontoolbox.Camera</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for machinevisiontoolbox.Camera</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Camera class</span>
<span class="sd">@author: Dorian Tsai</span>
<span class="sd">@author: Peter Corke</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="nn">cv</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">base</span><span class="p">,</span> <span class="n">Line3</span><span class="p">,</span> <span class="n">SO3</span>
<span class="kn">from</span> <span class="nn">machinevisiontoolbox.ImagePointFeatures</span> <span class="kn">import</span> <span class="n">FeatureMatch</span>
<span class="kn">from</span> <span class="nn">machinevisiontoolbox.base</span> <span class="kn">import</span> <span class="n">idisp</span>


<span class="c1"># from machinevisiontoolbox.classes import Image</span>
<span class="c1"># import CameraVisualizer as CamVis</span>

<span class="c1"># from mpl_toolkits.mplot3d import Axes3D, art3d</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d.art3d</span> <span class="kn">import</span> <span class="n">Poly3DCollection</span>

<span class="c1"># from collections import namedtuple</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">SE3</span>
<span class="kn">import</span> <span class="nn">spatialmath.base</span> <span class="k">as</span> <span class="nn">smbase</span>

<span class="kn">from</span> <span class="nn">machinevisiontoolbox</span> <span class="kn">import</span> <span class="n">Image</span>

<div class="viewcode-block" id="CameraBase"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase">[docs]</a><span class="k">class</span> <span class="nc">CameraBase</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>

    <span class="c1"># list of attributes</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># camera  name (string)</span>
    <span class="n">_camtype</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># camera type (string)</span>

    <span class="n">_imagesize</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># number of pixels (horizontal, vertical)</span>
    <span class="n">_pp</span> <span class="o">=</span> <span class="kc">None</span>        <span class="c1"># principal point (horizontal, vertical)</span>
    <span class="n">_rhou</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># pixel imagesize (single pixel) horizontal</span>
    <span class="n">_rhov</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># pixel imagesize (single pixel) vertical</span>
    <span class="n">_image</span> <span class="o">=</span> <span class="kc">None</span>     <span class="c1"># image (TODO image class?), for now, just numpy array</span>

    <span class="n">_T</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># camera pose (homogeneous transform, SE3 class)</span>

    <span class="n">_ax</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># for plotting, axes handle</span>

<div class="viewcode-block" id="CameraBase.__init__"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">camtype</span><span class="o">=</span><span class="s1">&#39;central&#39;</span><span class="p">,</span>
                 <span class="n">rho</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">imagesize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sensorsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Abstract camera base class</span>

<span class="sd">        :param name: camera instance name, defaults to None</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        :param camtype: camera projection type, defaults to &#39;central&#39;</span>
<span class="sd">        :type camtype: str, optional</span>
<span class="sd">        :param rho: pixel size, defaults to 1</span>
<span class="sd">        :type rho: scalar or array_like(2), optional</span>
<span class="sd">        :param imagesize: image dimension in pixels, defaults to None</span>
<span class="sd">        :type imagesize: int or array_like(2), optional</span>
<span class="sd">        :param sensorsize: image sensor size, defaults to None</span>
<span class="sd">        :type sensorsize: array_like(2), optional</span>
<span class="sd">        :param pp: principal point position, defaults to None</span>
<span class="sd">        :type pp: array_like(2), optional</span>
<span class="sd">        :param noise: standard deviation of image plane projection noise, defaults to None</span>
<span class="sd">        :type noise: float, optional</span>
<span class="sd">        :param pose: camera pose, defaults to None</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param limits: bounds of virtual image plane [umin, umax, vmin, vmax], defaults to None</span>
<span class="sd">        :type limits: array_like(4), optional</span>
<span class="sd">        :param labels: axis labels for virtual image plane, defaults to (&#39;u&#39;, &#39;v&#39;)</span>
<span class="sd">        :type labels: 2-tuple of str, optional</span>
<span class="sd">        :param seed: random number seed for projection noise, defaults to None</span>
<span class="sd">        :type seed: int, optional</span>
<span class="sd">        :raises TypeError: name must be a string</span>
<span class="sd">        :raises TypeError: camtype must be a string</span>
<span class="sd">        :raises ValueError: rho must be a 1- or 2-element vector</span>

<span class="sd">        This abstract class is the base for all camera projection model</span>
<span class="sd">        classes.  All baseclass constructors support these options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">camtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;name must be a string&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">camtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">camtype</span><span class="p">,</span> <span class="s1">&#39;camtype must be a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_camtype</span> <span class="o">=</span> <span class="n">camtype</span>

        <span class="k">if</span> <span class="n">imagesize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pp</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span> <span class="o">=</span> <span class="n">imagesize</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pp</span> <span class="o">=</span> <span class="n">pp</span>

        <span class="k">if</span> <span class="n">sensorsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span> <span class="o">=</span> <span class="n">sensorsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span> <span class="o">=</span> <span class="n">sensorsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="s1">&#39;rho must be a 1- or 2-element vector&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">noise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">pose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pose0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">noise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">limits</span></div>

<div class="viewcode-block" id="CameraBase.reset"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset camera pose (base method)</span>

<span class="sd">        Restore camera to a copy of the pose given to the constructor.  The copy</span>
<span class="sd">        means that the camera pose can be modified freely, without destroying</span>
<span class="sd">        the initial pose value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of camera parameters (base method)</span>

<span class="sd">        :return: string representation</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Multi-line string representation of camera intrinsic and extrinsic</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO, imagesize should be integers</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:&gt;15s}</span><span class="s1">: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Name&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;pixel size&#39;</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;image size&#39;</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span><span class="p">]))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;pose&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">strline</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;rpy/yxz&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Readable representatio of camera parameters (base method)</span>

<span class="sd">        :return: string representation</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Multi-line string representation of camera intrinsic and extrinsic</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">project_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;not implemented for this camera model&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">project_conic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;not implemented for this camera model&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get camera name (base method)</span>

<span class="sd">        A camera has a string-valued name that can be read and written.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.name</span>
<span class="sd">            &gt;&gt;&gt; camera.name = &quot;foo&quot;</span>
<span class="sd">            &gt;&gt;&gt; camera.name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set camera name</span>

<span class="sd">        :param newname: camera name</span>
<span class="sd">        :type newname: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">newname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">newname</span><span class="p">,</span> <span class="s1">&#39;name must be a string&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">camtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get camera type (base method)</span>

<span class="sd">        A camera has a string-valued type that can be read and written.  This</span>
<span class="sd">        is unique to the camera subclass and projection model.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.camtype</span>
<span class="sd">            &gt;&gt;&gt; camera.camtype = &quot;foo&quot;</span>
<span class="sd">            &gt;&gt;&gt; camera.camtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_camtype</span>

    <span class="nd">@camtype</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">camtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newcamtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set camera type</span>

<span class="sd">        :param newcamtype: camera projection type</span>
<span class="sd">        :type newcamtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newcamtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_camtype</span> <span class="o">=</span> <span class="n">newcamtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">newcamtype</span><span class="p">,</span> <span class="s1">&#39;camtype must be a string&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imagesize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get size of virtual image plane (base method)</span>

<span class="sd">        The dimensions of the virtual image plane is a 2-tuple, width and</span>
<span class="sd">        height, that can be read or written.  For writing the size must be an</span>
<span class="sd">        iterable of length 2.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.imagesize</span>
<span class="sd">            &gt;&gt;&gt; camera.imagesize = (500, 500)</span>
<span class="sd">            &gt;&gt;&gt; camera.imagesize</span>

<span class="sd">        .. note:: If the principal point is not set, then setting imagesize</span>
<span class="sd">            sets the principal point to the centre of the image plane.</span>

<span class="sd">        :seealso: :meth:`width` :meth:`height` :meth:`nu` :meth:`nv`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span>

    <span class="nd">@imagesize</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imagesize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">npix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set image plane size</span>

<span class="sd">        :param npix: [description]</span>
<span class="sd">        :type npix: array_like(2)</span>
<span class="sd">        :raises ValueError: bad value</span>

<span class="sd">        Sets the size of the virtual image plane.</span>
<span class="sd">        </span>
<span class="sd">        .. note:: If the principle point is not set, then it</span>
<span class="sd">            is set to the centre of the image plane.</span>

<span class="sd">        :seealso: :meth:`width` :meth:`height` :meth:`nu` :meth:`nv`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npix</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">npix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">npix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npix</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="c1"># ignore color dimension in case it is given</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span> <span class="o">=</span> <span class="n">npix</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">npix</span><span class="p">,</span> <span class="s1">&#39;imagesize must be a 1- or 2-element vector&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get image plane width (base method)</span>

<span class="sd">        :return: width</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Number of pixels in the u-direction (width)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.nu</span>

<span class="sd">        :seealso: :meth:`nv` :meth:`width` :meth:`imagesize`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get image plane height (base method)</span>

<span class="sd">        :return: height</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Number of pixels in the v-direction (height)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.nv</span>

<span class="sd">        :seealso: :meth:`nu` :meth:`height`  :meth:`imagesize`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get image plane width (base method)</span>

<span class="sd">        :return: width</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Image plane height, number of pixels in the v-direction</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.width</span>

<span class="sd">        :seealso: :meth:`nu` :meth:`height`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get image plane height (base method)</span>

<span class="sd">        :return: height</span>
<span class="sd">        :rtype: int</span>

<span class="sd">        Image plane width, number of pixels in the u-direction</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.height</span>

<span class="sd">        :seealso: :meth:`nv` :meth:`width`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagesize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get principal point coordinate (base method)</span>

<span class="sd">        The principal point is the coordinate of the point where</span>
<span class="sd">        the optical axis pierces the image plane.  It is a 2-tuple which can</span>
<span class="sd">        be read or written.  For writing the size must be an</span>
<span class="sd">        iterable of length 2.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.pp</span>

<span class="sd">        :seealso: :meth:`u0` :meth:`v0`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span>

    <span class="nd">@pp</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set principal point coordinate</span>

<span class="sd">        :param pp: principal point</span>
<span class="sd">        :type pp: array_like(2)</span>

<span class="sd">        :seealso: :meth:`pp` :meth:`u0` :meth:`v0`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span> <span class="o">=</span> <span class="n">pp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="s1">&#39;pp must be a 1- or 2-element vector&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">u0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get principal point: horizontal coordinate (base method)</span>

<span class="sd">        :return: horizontal component of principal point</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.u0</span>

<span class="sd">        :seealso: :meth:`v0` :meth:`pp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get principal point: vertical coordinate (base method)</span>

<span class="sd">        :return: vertical component of principal point</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.v0</span>

<span class="sd">        :seealso: :meth:`u0` :meth:`pp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhou</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pixel width (base method)</span>

<span class="sd">        :return: horizontal pixel size</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.rhou</span>

<span class="sd">        :seealso: :meth:`rhov` :meth:`rho`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span>

    <span class="c1"># this is generally the centre of the image, has special meaning for</span>
    <span class="c1"># perspective camera</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pixel width (base method)</span>

<span class="sd">        :return: vertical pixel size</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.rhov</span>

<span class="sd">        :seealso: :meth:`rhov` :meth:`rho`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pixel dimensions (base method)</span>

<span class="sd">        :return: horizontal pixel size</span>
<span class="sd">        :rtype: ndarray(2)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.rhov</span>

<span class="sd">        :seealso: :meth:`rhou` :meth:`rhov`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span><span class="p">])</span>

    <span class="c1"># @property</span>
    <span class="c1"># def image(self):</span>
    <span class="c1">#     return self._image</span>

    <span class="c1"># @image.setter</span>
    <span class="c1"># def image(self, newimage):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>


    <span class="c1">#     :param newimage: [description]</span>
    <span class="c1">#     :type newimage: [type]</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     self._image = Image(newimage)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get camera pose (base method)</span>

<span class="sd">        The camera pose with respect to the global frame can be read or written</span>
<span class="sd">        as an :class:`~spatialmath..pose3d.SE3` instance.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.pose</span>
<span class="sd">            &gt;&gt;&gt; camera.pose = SE3.Trans(1, 2, 3)</span>
<span class="sd">            &gt;&gt;&gt; camera</span>

<span class="sd">        .. note:: Changes the pose of the current camera instance, whereas</span>
<span class="sd">            :meth:`move` clones the camera instance with a new pose.</span>

<span class="sd">        :seealso: :meth:`move`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pose</span>

    <span class="nd">@pose</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newpose</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set camera pose</span>

<span class="sd">        :param newpose: pose of camera frame</span>
<span class="sd">        :type newpose: :class:`~spatialmath..pose3d.SE3` or ndarray(4,4)</span>

<span class="sd">        :seealso: :meth:`move`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">newpose</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/Get projection noise (base method)</span>

<span class="sd">        :return: standard deviation of noise added to projected image plane points</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        The noise parameter is set by the object constructor.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default();</span>
<span class="sd">            &gt;&gt;&gt; camera.project_point([0, 0, 3])</span>
<span class="sd">            &gt;&gt;&gt; camera.noise = 2</span>
<span class="sd">            &gt;&gt;&gt; camera.project_point([0, 0, 2])</span>
<span class="sd">            &gt;&gt;&gt; camera.project_point([0, 0, 2])</span>

<span class="sd">        :seealso: :meth:`project`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span>

    <span class="nd">@noise</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_noise</span> <span class="o">=</span> <span class="n">noise</span>

<div class="viewcode-block" id="CameraBase.move"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move camera (base method)</span>

<span class="sd">        :param T: pose of camera frame</span>
<span class="sd">        :type T: :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        :param relative: move relative to pose of original camera, defaults to False</span>
<span class="sd">        :type relative: bool, optional</span>
<span class="sd">        :return: new camera object</span>
<span class="sd">        :rtype: :class:`CameraBase` subclass</span>

<span class="sd">        Returns a copy of the camera object with pose set to ``T``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera();</span>
<span class="sd">            &gt;&gt;&gt; camera.move(SE3.Trans(0.1, 0.2, 0.3))</span>
<span class="sd">            &gt;&gt;&gt; camera</span>

<span class="sd">        .. note:: The ``plot`` method of this cloned camera will create a new</span>
<span class="sd">            window.</span>

<span class="sd">        :seealso: :meth:`pose`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newcamera</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">newcamera</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newcamera</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;-moved&quot;</span>
        <span class="n">newcamera</span><span class="o">.</span><span class="n">_ax</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">relative</span><span class="p">:</span>
            <span class="n">newcamera</span><span class="o">.</span><span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span> <span class="o">*</span> <span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newcamera</span><span class="o">.</span><span class="n">pose</span> <span class="o">=</span> <span class="n">T</span>
        <span class="k">return</span> <span class="n">newcamera</span></div>

    <span class="c1"># ----------------------- plotting ----------------------------------- #</span>

    <span class="k">def</span> <span class="nf">_new_imageplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new virtual image plane if required</span>

<span class="sd">        :param fig: Matplotlib figure number, defaults to None</span>
<span class="sd">        :type fig: int, optional</span>
<span class="sd">        :param ax: Matplotlob axes, defaults to None</span>
<span class="sd">        :type ax: :class:`matplotlib.axes`, optional</span>
<span class="sd">        :return: existing image plane</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        If this camera already has a virtual image plane, return True.</span>
<span class="sd">        Otherwise, create an axes, and optionally a  figure, and return False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># create our own handle for the figure/plot</span>
            <span class="c1"># print(&#39;creating new figure and axes for camera&#39;)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>  <span class="c1"># TODO *args, **kwargs?</span>
        <span class="c1"># TODO elif ax is a plot handle, else raise ValueError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fig</span> <span class="o">=</span> <span class="n">fig</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_init_imageplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create plot window for camera image plane</span>

<span class="sd">        :param fig: figure to plot into, defaults to None</span>
<span class="sd">        :type fig: figure handle, optional</span>
<span class="sd">        :param ax: axis to plot into, defaults to None</span>
<span class="sd">        :type ax: 2D axis handle, optional</span>
<span class="sd">        :return: figure and axis</span>
<span class="sd">        :rtype: (fig, axis)</span>

<span class="sd">        Creates a 2D axis that represents the image plane of the virtual</span>
<span class="sd">        camera.</span>

<span class="sd">        :seealso: :meth:`plot` :meth:`mesh`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_imageplane</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if camera has an image, display said image</span>
            <span class="n">idisp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image</span><span class="p">,</span>
                      <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                      <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                      <span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                      <span class="n">drawonly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;u (pixels)&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;v (pixels)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;lightyellow&#39;</span><span class="p">)</span>
                
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">set_window_title</span><span class="p">(</span><span class="s1">&#39;Machine Vision Toolbox for Python&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># can happen during unit test without GUI</span>
                <span class="k">pass</span>

        <span class="c1"># TODO figure out axes ticks, etc</span>
        <span class="k">return</span> <span class="n">ax</span>  <span class="c1"># likely this return is not necessary</span>

<div class="viewcode-block" id="CameraBase.clf"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.clf">[docs]</a>    <span class="k">def</span> <span class="nf">clf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the virtual image plane (base method)</span>

<span class="sd">        Every camera object has a virtual image plane drawn using Matplotlib.</span>
<span class="sd">        Remove all points and lines from the image plane.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`plot_point` :meth:`plot_line` :meth:`disp`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">artist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">artist</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span></div>

<div class="viewcode-block" id="CameraBase.plot_point"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.plot_point">[docs]</a>    <span class="k">def</span> <span class="nf">plot_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">return_artist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot points on virtual image plane (base method)</span>

<span class="sd">        :param P: 3D world point or points, or 2D image plane point or points</span>
<span class="sd">        :type P: ndarray(3,), ndarray(3,N), or ndarray(2,), ndarray(2,N)</span>
<span class="sd">        :param objpose: transformation for the 3D points, defaults to None</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param pose: pose of the camera, defaults to None</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param ax: axes to plot into</span>
<span class="sd">        :type ax: :class:`matplotlib.axes`</span>
<span class="sd">        :param kwargs: additional arguments passed to :obj:`~matplotlib.pyplot.plot`</span>
<span class="sd">        :return: Matplotlib line objects</span>
<span class="sd">        :rtype: list of :class:`~matplotlib.lines.Line2d`</span>

<span class="sd">        3D world points are first projected to the image plane and then </span>
<span class="sd">        plotted on the camera&#39;s virtual image plane.</span>
<span class="sd">        Points are organized as columns of the arrays.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.plot_point([0.2, 0.3, 2])</span>
<span class="sd">            &gt;&gt;&gt; camera.plot_point([0.2, 0.3, 2], &#39;r*&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.plot_point([0.2, 0.3, 2], pose=SE3(0.1, 0, 0))</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            camera = CentralCamera.Default()</span>
<span class="sd">            camera.plot_point([0.2, 0.3, 2])</span>
<span class="sd">            camera.plot_point([0.2, 0.3, 2], &#39;r*&#39;)</span>
<span class="sd">            camera.plot_point([0.2, 0.3, 2], pose=SE3(0.1, 0, 0))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - Successive calls add items to the virtual image plane.</span>
<span class="sd">            - This method is common to all ``CameraBase`` subclasses, but it</span>
<span class="sd">              invokes a camera-specific projection method.</span>

<span class="sd">        :seealso: :meth:`plot_line2` :meth:`plot_line3` :meth:`plot_wireframe` :meth:`clf`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_imageplane</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># plot world points</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="n">objpose</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># plot image plane points</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">P</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;p must have be (2,), (3,), (2,n), (3,n)&#39;</span><span class="p">)</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;o&#39;</span><span class="p">]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>

        <span class="n">artist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_artist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">artist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="CameraBase.plot_line2"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.plot_line2">[docs]</a>    <span class="k">def</span> <span class="nf">plot_line2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot 2D line on virtual image plane (base method)</span>

<span class="sd">        :param l: homogeneous line</span>
<span class="sd">        :type l: array_like(3)</span>
<span class="sd">        :param kwargs: arguments passed to ``plot``</span>

<span class="sd">        Plot the homogeneous line on the camera&#39;s virtual image plane. The line</span>
<span class="sd">        is expressed in the form</span>
<span class="sd">        </span>
<span class="sd">        .. math:: \ell_0 u + \ell_1 v + \ell_2 = 0</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.plot_line2([1, 0.2, -500])</span>

<span class="sd">        .. note::</span>
<span class="sd">            - Successive calls add items to the virtual image plane.</span>
<span class="sd">            - This method is common to all ``CameraBase`` subclasses, but it</span>
<span class="sd">              invokes a camera-specific projection method.</span>

<span class="sd">        :seealso: :meth:`plot_point` :meth:`plot_line3` :meth:`clf`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get handle for this camera image plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_imageplane</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">base</span><span class="o">.</span><span class="n">plot_homline</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># def plot_line3(self, L, nsteps=21, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Plot 3D line on virtual image plane (base method)</span>

    <span class="c1">#     :param L: 3D line or lines in Plucker coordinates</span>
    <span class="c1">#     :type L: :class:`~spatialmath..geom3d.Line3`</span>
    <span class="c1">#     :param kwargs: arguments passed to ``plot``</span>

    <span class="c1">#     The Plucker lines are projected to the camera&#39;s virtual image plane and</span>
    <span class="c1">#     plotted.  Each line is approximated by ``nsteps`` points, each of which</span>
    <span class="c1">#     is projected, allowing straight lines to appear curved after projection.</span>

    <span class="c1">#     Example:</span>

    <span class="c1">#     .. runblock:: pycon</span>

    <span class="c1">#         &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkcube</span>
    <span class="c1">#         &gt;&gt;&gt; from spatialmath import Line3</span>
    <span class="c1">#         &gt;&gt;&gt; camera = CentralCamera()</span>
    <span class="c1">#         &gt;&gt;&gt; line = Line3.Join((-1, -2, -3), (4, 5, 6))</span>
    <span class="c1">#         &gt;&gt;&gt; camera.plot_line3(line, &#39;k--&#39;)</span>

    <span class="c1">#     .. note::</span>
    <span class="c1">#         - Successive calls add items to the virtual image plane.</span>
    <span class="c1">#         - This method is common to all ``CameraBase`` subclasses, but it</span>
    <span class="c1">#           invokes a camera-specific projection method.</span>
              
    <span class="c1">#     :seealso: :meth:`plot_point` :meth:`plot_line2` :meth:`plot_wireframe` :meth:`clf`</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     # draw 3D line segments</span>
    <span class="c1">#     s = np.linspace(0, 1, nsteps)</span>

        <span class="c1"># this is actually pretty tricky</span>
        <span class="c1">#  - how to determine which part of the 3D line is visible</span>
        <span class="c1">#  - if highly curved it may be in two or more segments</span>
        <span class="c1"># for line in L:</span>
        <span class="c1">#     l = self.project_line(line)</span>

        <span class="c1">#     # straight world lines are not straight, plot them piecewise</span>
        <span class="c1">#     P = (1 - s) * P0[:, np.newaxis] + s * P2[:, np.newaxis]</span>
        <span class="c1">#     uv = self.project_point(P, pose=pose)</span>

<div class="viewcode-block" id="CameraBase.plot_wireframe"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.plot_wireframe">[docs]</a>    <span class="k">def</span> <span class="nf">plot_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot 3D wireframe in virtual image plane (base method)</span>

<span class="sd">        :param X: world X coordinates</span>
<span class="sd">        :type X: ndarray(N,M)</span>
<span class="sd">        :param Y: world Y coordinates</span>
<span class="sd">        :type Y: ndarray(N,M)</span>
<span class="sd">        :param Z: world Z coordinates</span>
<span class="sd">        :type Z: ndarray(N,M)</span>
<span class="sd">        :param objpose: transformation for the wireframe points, defaults to None</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param pose: pose of the camera, defaults to None</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param nsteps: number of points for each wireframe segment, defaults to 21</span>
<span class="sd">        :type nsteps: int, optional</span>
<span class="sd">        :param kwargs: arguments passed to ``plot``</span>

<span class="sd">        The 3D wireframe is projected to the camera&#39;s virtual image plane.  Each</span>
<span class="sd">        wire link in the wireframe is approximated by ``nsteps`` points, each of</span>
<span class="sd">        which is projected, allowing straight edges to appear curved.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkcube</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; X, Y, Z = mkcube(0.2, pose=SE3(0, 0, 1), edge=True)</span>
<span class="sd">            &gt;&gt;&gt; camera.plot_wireframe(X, Y, Z, &#39;k--&#39;)</span>

<span class="sd">        .. plot::</span>

<span class="sd">            from machinevisiontoolbox import CentralCamera, mkcube</span>
<span class="sd">            from spatialmath import SE3</span>
<span class="sd">            camera = CentralCamera.Default()</span>
<span class="sd">            X, Y, Z = mkcube(0.2, pose=SE3(0, 0, 1), edge=True)</span>
<span class="sd">            camera.plot_wireframe(X, Y, Z, &#39;k--&#39;)</span>

<span class="sd">        :seealso: :func:`mkcube` :obj:`spatialmath.base.cylinder` :obj:`spatialmath.base.sphere` :obj:`spatialmath.base.cuboid`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># self._ax.plot_surface(X, Y, Z)</span>
        <span class="c1"># plt.show()</span>
   
        <span class="c1"># check that mesh matrices conform</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrices must be the same shape&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>
        <span class="k">if</span> <span class="n">objpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="n">objpose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">pose</span>
        
        <span class="c1"># get handle for this camera image plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_imageplane</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># draw 3D line segments</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">)</span>

        <span class="c1"># c.clf</span>
        <span class="c1"># holdon = c.hold(1);</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>      <span class="c1"># i=1:numrows(X)-1</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># j=1:numcols(X)-1</span>
                <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
                <span class="n">P1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
                <span class="n">P2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">camtype</span> <span class="o">==</span> <span class="s1">&#39;perspective&#39;</span><span class="p">:</span>
                    <span class="c1"># straight world lines are straight on the image plane</span>
                    <span class="n">uv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">],</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># straight world lines are not straight, plot them piecewise</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">P0</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">P1</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="n">uv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">camtype</span> <span class="o">==</span> <span class="s1">&#39;perspective&#39;</span><span class="p">:</span>
                    <span class="c1"># straight world lines are straight on the image plane</span>
                    <span class="n">uv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">P2</span><span class="p">],</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># straight world lines are not straight, plot them piecewise</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">P0</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">P2</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="n">uv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># j=1:numcols(X)-1</span>
            <span class="n">P0</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>   <span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">],</span>   <span class="n">Z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">P1</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="c1"># if c.perspective</span>
                <span class="c1"># straight world lines are straight on the image plane</span>
            <span class="n">uv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">],</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">);</span>
            <span class="c1"># else</span>
            <span class="c1">#     # straight world lines are not straight, plot them piecewise</span>
            <span class="c1">#     P = bsxfun(@times, (1-s), P0) + bsxfun(@times, s, P1);</span>
            <span class="c1">#     uv = c.project(P, &#39;setopt&#39;, opt);</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">uv</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">uv</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c1"># c.hold(holdon); # turn hold off if it was initially off</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

<div class="viewcode-block" id="CameraBase.disp"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.disp">[docs]</a>    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display image on virtual image plane (base method)</span>

<span class="sd">        :param im: image to display</span>
<span class="sd">        :type im: :class:`Image` instance</span>
<span class="sd">        :param kwargs: options to :func:`~machinevisiontoolbox.base.imageio.idisp()`</span>

<span class="sd">        An image is displayed on camera&#39;s the virtual image plane.  </span>
<span class="sd">        </span>
<span class="sd">        .. note: The dimensions of the image plane should match the dimensions of the image.</span>

<span class="sd">        :seealso: :func:`machinevisiontoolbox.base.idisp()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span> <span class="o">=</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_imageplane</span><span class="p">()</span>
        <span class="n">im</span><span class="o">.</span><span class="n">disp</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ax</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CameraBase.plot"><a class="viewcode-back" href="../../camera.html#machinevisiontoolbox.Camera.CameraBase.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;camera&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot 3D camera icon in world view (base method)</span>

<span class="sd">        :param pose: camera pose</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        :param scale: scale factor, defaults to 1</span>
<span class="sd">        :type scale: float</span>
<span class="sd">        :param shape: icon shape: &#39;frustum&#39; [default], &#39;camera&#39;</span>
<span class="sd">        :type shape: str, optional</span>
<span class="sd">        :param label: show camera name, defaults to True</span>
<span class="sd">        :type label: bool, optional</span>
<span class="sd">        :param alpha: transparency of icon, defaults to 1</span>
<span class="sd">        :type alpha: float, optional</span>
<span class="sd">        :param solid: icon comprises solid faces, defaults to False</span>
<span class="sd">        :type solid: bool, optional</span>
<span class="sd">        :param color: icon color, defaults to &#39;r&#39;</span>
<span class="sd">        :type color: str, optional</span>
<span class="sd">        :param projection: projection model for new axes, defaults to &#39;ortho&#39;</span>
<span class="sd">        :type projection: str, optional</span>
<span class="sd">        :param ax: axes to draw in, defaults to current 3D axes</span>
<span class="sd">        :type ax: :class:`~matplotlib.Axes3D`, optional</span>
<span class="sd">        :return: axes drawn into</span>
<span class="sd">        :rtype: :class:`~matplotlib.Axes3D`</span>

<span class="sd">        Plot a 3D icon representing the pose of a camera into a 3D Matplotlib</span>
<span class="sd">        plot.  Two icons are supported: the traditional frustum, and a</span>
<span class="sd">        simplistic camera comprising a box and cylinder.</span>

<span class="sd">        .. note:: If ``pose`` is not given it defaults to the pose of the</span>
<span class="sd">            instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if (fig is None) and (ax is None):</span>
        <span class="c1">#     # create our own handle for the figure/plot</span>
        <span class="c1">#     print(&#39;creating new figure and axes for camera&#39;)</span>
        <span class="c1">#     fig = plt.figure()</span>
        <span class="c1">#     ax = fig.gca(projection=&#39;3d&#39;)</span>
        <span class="c1">#     # ax.set_aspect(&#39;equal&#39;)</span>

        <span class="sd">&quot;&quot;&quot;[summary]</span>
<span class="sd">        face order -x, +y, +x, -y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get axes to draw in</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">smbase</span><span class="o">.</span><span class="n">axes_logic</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>

        <span class="c1"># draw camera-like object:</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;frustum&#39;</span><span class="p">:</span>
            <span class="c1"># TODO make this kwargs or optional inputs</span>
            <span class="c1"># side colors:</span>
            <span class="c1">#  +x red</span>
            <span class="c1">#  -y red</span>
            <span class="c1">#  +y green</span>
            <span class="c1">#  -y yellow</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">widthb</span> <span class="o">=</span> <span class="n">scale</span><span class="o">/</span><span class="mi">10</span>
            <span class="n">widtht</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">widthb</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">widtht</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">widthb</span><span class="p">,</span> <span class="o">-</span><span class="n">widthb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">widthb</span><span class="p">,</span> <span class="n">widthb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">widthb</span><span class="p">,</span> <span class="n">widthb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">b3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">widthb</span><span class="p">,</span> <span class="o">-</span><span class="n">widthb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">widtht</span><span class="p">,</span> <span class="o">-</span><span class="n">widtht</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">widtht</span><span class="p">,</span> <span class="n">widtht</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">widtht</span><span class="p">,</span> <span class="n">widtht</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">t3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">widtht</span><span class="p">,</span> <span class="o">-</span><span class="n">widtht</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># bottom/narrow end</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">pose</span><span class="o">.</span><span class="n">A</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">b0</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">b1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">b2</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">b3</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">b3</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># wide/top end</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">t0</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">t1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">t2</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">t3</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">t3</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Each set of four points is a single side of the Frustrum</span>
            <span class="c1"># points = np.array([[b0, b1, t1, t0], [b1, b2, t2, t1], [</span>
            <span class="c1">#                   b2, b3, t3, t2], [b3, b0, t0, t3]])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">]),</span>  <span class="c1"># -x face</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">]),</span>  <span class="c1"># +y face</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">t3</span><span class="p">,</span> <span class="n">t2</span><span class="p">]),</span>  <span class="c1"># +x face</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b3</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t3</span><span class="p">])</span>   <span class="c1"># -y face</span>
            <span class="p">]</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly3DCollection</span><span class="p">(</span><span class="n">points</span><span class="p">,</span>
                                    <span class="n">facecolors</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection3d</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s1">&#39;camera&#39;</span><span class="p">:</span>

            <span class="c1"># the box is centred at the origin and its centerline parallel to the</span>
            <span class="c1"># z-axis.  Its z-extent is -bh/2 to bh/2.</span>
            <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span>       <span class="c1"># width &amp; height of the box</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mf">1.2</span>       <span class="c1"># length of the box</span>
            <span class="n">cr</span> <span class="o">=</span> <span class="mf">0.2</span>       <span class="c1"># cylinder radius</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="mf">0.4</span>       <span class="c1"># cylinder height</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="mi">12</span>        <span class="c1"># number of facets of cylinder</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>          <span class="c1"># length of axis line segments</span>

            <span class="c1"># draw the box part of the camera</span>
            <span class="n">smbase</span><span class="o">.</span><span class="n">plot_cuboid</span><span class="p">(</span><span class="n">sides</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">W</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">L</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="n">solid</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span> <span class="k">if</span> <span class="n">solid</span> <span class="k">else</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

            <span class="c1"># draw the lens</span>
            <span class="n">smbase</span><span class="o">.</span><span class="n">plot_cylinder</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">cr</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">L</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ch</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">cn</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="n">solid</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">frame</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">scale</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">flo</span><span class="o">=</span><span class="p">(</span><span class="mf">0.07</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">frame</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="k">def</span> <span class="nf">_add_noise_distortion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add noise to pixel coordinates</span>

<span class="sd">        :param uv: image plane point coordinates</span>
<span class="sd">        :type uv: ndarray(2,N)</span>
<span class="sd">        :return: point coordinates with additive noise</span>
<span class="sd">        :rtype: ndarray(2,N)</span>

<span class="sd">        Model noise in the image process by adding zero-mean Gaussian noise</span>
<span class="sd">        to the coordinates of projected world points.  The noise has a</span>
<span class="sd">        standard deviation specified by the camera constructor.</span>

<span class="sd">        :seealso: :meth:`noise`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># distort the pixels</span>
        
        <span class="c1"># add Gaussian noise with specified standard deviation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uv</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">uv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">uv</span> </div>

<div class="viewcode-block" id="CentralCamera"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera">[docs]</a><span class="k">class</span> <span class="nc">CentralCamera</span><span class="p">(</span><span class="n">CameraBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. inheritance-diagram:: machinevisiontoolbox.Camera.CentralCamera</span>
<span class="sd">        :top-classes: machinevisiontoolbox.Camera.Camera</span>
<span class="sd">        :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">f</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">distortion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create central camera projection model</span>

<span class="sd">        :param f: focal length, defaults to 8mm</span>
<span class="sd">        :type f: float, optional</span>
<span class="sd">        :param distortion: camera distortion parameters, defaults to None</span>
<span class="sd">        :type distortion: array_like(5), optional</span>
<span class="sd">        :param kwargs: arguments passed to :class:`CameraBase` constructor</span>

<span class="sd">        A camera object contains methods for projecting 3D points and lines</span>
<span class="sd">        to the image plane, as well as supporting a virtual image plane onto</span>
<span class="sd">        which 3D points and lines can be drawn.</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`CameraBase` :class:`FishEyeCamera` :class:`SphericalCamera`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camtype</span><span class="o">=</span><span class="s1">&#39;perspective&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># TODO some of this logic to f and pp setters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span> <span class="o">=</span> <span class="n">distortion</span>

<div class="viewcode-block" id="CentralCamera.Default"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.Default">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Default</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set default central camera parameters</span>

<span class="sd">        :return: central camera model</span>
<span class="sd">        :rtype: :class:`CentralCamera` instance</span>

<span class="sd">        Initialize a central camera with: focal length of 8mm, :math:`10\mu`m pixels,</span>
<span class="sd">        image size of :math:`1000 \times 1000` with principal point at (500, 500).</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`CentralCamera`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">0.008</span><span class="p">,</span> 
            <span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="mf">10e-6</span><span class="p">,</span>
            <span class="s1">&#39;imagesize&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> 
            <span class="s1">&#39;pp&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span><span class="mi">500</span><span class="p">),</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;default perspective camera&#39;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">CentralCamera</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="n">default</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">})</span></div>
        
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of central camera parameters</span>

<span class="sd">        :return: string representation</span>
<span class="sd">        :rtype: str</span>

<span class="sd">        Multi-line string representation of camera intrinsic and extrinsic</span>
<span class="sd">        parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;principal pt&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pp</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;focal length&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>


<div class="viewcode-block" id="CentralCamera.project_point"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.project_point">[docs]</a>    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">behind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">visibility</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retinal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D points to image plane</span>

<span class="sd">        :param P: 3D world point or points</span>
<span class="sd">        :type P: array_like(3), array_like(3,n)</span>
<span class="sd">        :param pose: camera pose with respect to the world frame, defaults to</span>
<span class="sd">            camera&#39;s ``pose`` attribute</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param objpose:  3D point reference frame, defaults to world frame</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param behind: points behind the camera indicated by NaN, defaults to True</span>
<span class="sd">        :type behind: bool, optional</span>
<span class="sd">        :param visibility: return visibility array, defaults to False</span>
<span class="sd">        :type visibility: bool</span>
<span class="sd">        :param retinal: transform to retinal coordinates, defaults to False</span>
<span class="sd">        :type retinal: bool, optional</span>
<span class="sd">        :return: image plane points, optional visibility vector</span>
<span class="sd">        :rtype: ndarray(2,n), ndarray(n)</span>

<span class="sd">        Project a 3D point to the image plane</span>

<span class="sd">        .. math::</span>

<span class="sd">            \hvec{p} = \mat{C} \hvec{P}</span>

<span class="sd">        where :math:`\mat{C}` is the camera calibration matrix and</span>
<span class="sd">        :math:`\hvec{p}` and :math:`\hvec{P}` are the image plane and world</span>
<span class="sd">        frame coordinates respectively, in homogeneous form. </span>
<span class="sd">        </span>
<span class="sd">        World points are given as a 1D array or the columns of a 2D array of</span>
<span class="sd">        Euclidean coordinates. The computed image plane coordinates are</span>
<span class="sd">        Euclidean and given as a 1D array or the corresponding columns of a 2D</span>
<span class="sd">        array.</span>

<span class="sd">        If ``pose`` is specified it is used for the camera frame pose, otherwise</span>
<span class="sd">        the attribute ``pose`` is used.  The object&#39;s ``pose`` attribute is not</span>
<span class="sd">        updated if ``pose`` is specified.</span>

<span class="sd">        A single point can be specified as a 3-vector, multiple points as an</span>
<span class="sd">        array with three rows and each column is the 3D point coordinate (X, Y,</span>
<span class="sd">        Z).</span>

<span class="sd">        The points ``P`` are by default with respect to the world frame, but </span>
<span class="sd">        they can be transformed by specifying ``objpose``.</span>
<span class="sd">        </span>
<span class="sd">        If world points are behind the camera and ``behind`` is True then the</span>
<span class="sd">        image plane coordinates are set to NaN.</span>
<span class="sd">        </span>
<span class="sd">        if ``visibility`` is True then each projected point is checked to ensure</span>
<span class="sd">        it lies in the bounds of the image plane.  In this case there are two</span>
<span class="sd">        return values: the image plane coordinates and an array of booleans</span>
<span class="sd">        indicating if the corresponding point is visible.</span>

<span class="sd">        If ``retinal`` is True then project points in retinal coordinates, </span>
<span class="sd">        in units of metres with respect to the principal point.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.project_point((0.3, 0.4, 2))</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`project_point` :meth:`project_line` :meth:`project_quadric`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>

        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="n">pose</span><span class="p">,</span> <span class="n">retinal</span><span class="o">=</span><span class="n">retinal</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># make it a column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;col&#39;</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>  <span class="c1"># make it homogeneous</span>

        <span class="c1"># project 3D points</span>

        <span class="k">if</span> <span class="n">objpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">objpose</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">P</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">P</span>

        <span class="k">if</span> <span class="n">behind</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># points behind the camera are set to NaN</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">h2e</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># add Gaussian noise and distortion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise_distortion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1">#  do visibility check if required</span>
        <span class="k">if</span> <span class="n">visibility</span><span class="p">:</span>
            <span class="n">visible</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span> \
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> \
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> \
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu</span><span class="p">)</span> \
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">visible</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="CentralCamera.project_line"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.project_line">[docs]</a>    <span class="k">def</span> <span class="nf">project_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D lines to image plane</span>

<span class="sd">        :param lines: Plucker line or lines</span>
<span class="sd">        :type lines: :class:`~spatialmath..geom3d.Line3` instance with N values</span>
<span class="sd">        :return: 2D homogeneous lines, one per column</span>
<span class="sd">        :rtype: ndarray(3,N)</span>

<span class="sd">        The :class:`~spatialmath..geom3d.Line3` object can contain multiple lines.  The result array has one</span>
<span class="sd">        column per line, and each column is a vector describing the image plane</span>
<span class="sd">        line in homogeneous form :math:`\ell_0 u + \ell_1 v + \ell_2 = 0`.</span>

<span class="sd">        The projection is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \ell = \vex{\mat{C} \sk{\vec{L}} \mat{C}^T}</span>

<span class="sd">        where :math:`\mat{C}` is the camera calibration matrix and :math:`\sk{\vec{L}}`</span>
<span class="sd">        is the skew matrix representation of the Plucker line.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import Line3</span>
<span class="sd">            &gt;&gt;&gt; line = Line3.Join((-3, -4, 5), (5, 2, 6))</span>
<span class="sd">            &gt;&gt;&gt; line</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera()</span>
<span class="sd">            &gt;&gt;&gt; camera.project_line(line)</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.7.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :class:`~spatialmath..geom3d.Line3` :meth:`project_point` :meth:`project_quadric`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">Line3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expecting Line3 lines&#39;</span><span class="p">)</span>
        <span class="c1"># project Plucker lines</span>

        <span class="n">lines2d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">vex</span><span class="p">(</span><span class="n">C</span>  <span class="o">@</span> <span class="n">line</span><span class="o">.</span><span class="n">skew</span><span class="p">()</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>  <span class="c1"># normalize by largest element</span>
            <span class="n">lines2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">lines2d</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.project_quadric"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.project_quadric">[docs]</a>    <span class="k">def</span> <span class="nf">project_quadric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D quadric to image plane</span>

<span class="sd">        :param Q: quadric matrix</span>
<span class="sd">        :type Q: ndarray(4,4)</span>
<span class="sd">        :return: image plane conic</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        Quadrics, short for quadratic surfaces, are a rich family of</span>
<span class="sd">        3-dimensional surfaces. There are 17 standard types including spheres,</span>
<span class="sd">        ellipsoids, hyper- boloids, paraboloids, cylinders and cones all</span>
<span class="sd">        described by points :math:`\vec{x} \in \mathbb{P}^3` such that</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \hvec{x}^{\top} \mat{Q} \hvec{x} = 0</span>

<span class="sd">        The outline of the quadric is projected to a conic section on the image</span>
<span class="sd">        plane</span>

<span class="sd">        .. math::</span>

<span class="sd">            c^* = \mat{C} \mat{Q}^* \mat{C}^T</span>

<span class="sd">        where :math:`(\mat{X})^* = det(\mat{X}) \mat{X}^{-1}` is the adjugate</span>
<span class="sd">        operator.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; T_cam = SE3.Trans(0.2, 0.1, -5) * SE3.Rx(0.2)</span>
<span class="sd">            &gt;&gt;&gt; Q = np.diag([1, 1, 1, -1])  # unit sphere at origin</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(f=0.015, pose=T_cam);</span>
<span class="sd">            &gt;&gt;&gt; camera.project_quadric(Q)</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.7.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`project_point` :meth:`project_line`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">smbase</span><span class="o">.</span><span class="n">ismatrix</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expecting 4x4 conic matrix&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()</span> <span class="o">@</span> <span class="n">Q</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="CentralCamera.epiline"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.epiline">[docs]</a>    <span class="k">def</span> <span class="nf">epiline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">camera2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute epipolar line</span>

<span class="sd">        :param p: image plane point or points</span>
<span class="sd">        :type p: array_like(2) or ndarray(2,N)</span>
<span class="sd">        :param camera2: second camera</span>
<span class="sd">        :type camera2: :class:`CentralCamera` instance</span>
<span class="sd">        :return: epipolar line or lines in homogeneous form</span>
<span class="sd">        :rtype: ndarray(3), ndarray(3,N)</span>
<span class="sd">    </span>
<span class="sd">        Compute the epipolar line in ``camera2`` induced by the image plane</span>
<span class="sd">        points ``p`` in the current camera.  Each line is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            \ell = \mat{F} {}^1 \hvec{p}</span>

<span class="sd">        which is in homogeneous form :math:`\ell_0 u + \ell_1 v + \ell_2 = 0`</span>
<span class="sd">        and the conjugate point :math:`{}^2 \vec{p}` lies on this line.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera.Default(pose=SE3(0.1, 0.05, 0), name=&#39;camera2&#39;)</span>
<span class="sd">            &gt;&gt;&gt; P = [-0.2, 0.3, 5]  # world point</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)  # project to first camera</span>
<span class="sd">            &gt;&gt;&gt; camera1.epiline(p1, camera2)   # epipolar line in second camera</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.2.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`plot_epiline` :meth:`CentralCamera.F`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># p is 3 x N, result is 3 x N</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">camera2</span><span class="p">)</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.plot_epiline"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.plot_epiline">[docs]</a>    <span class="k">def</span> <span class="nf">plot_epiline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot epipolar line</span>

<span class="sd">        :param F: fundamental matrix</span>
<span class="sd">        :type F: ndarray(3,3)</span>
<span class="sd">        :param p: image plane point or points</span>
<span class="sd">        :type p: array_like(2) or ndarray(2,N)</span>
<span class="sd">        :param fmt: line style argument passed to ``plot``</span>
<span class="sd">        :param kwargs: additional line style arguments passed to ``plot``</span>
<span class="sd">    </span>
<span class="sd">        Plot the epipolar line induced by the image plane points ``p`` in the</span>
<span class="sd">        camera&#39;s virtual image plane.  Each line is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            \ell = \mat{F} {}^1 \hvec{p}</span>

<span class="sd">        which is in homogeneous form :math:`\ell_0 u + \ell_1 v + \ell_2 = 0`</span>
<span class="sd">        and the conjugate point :math:`{}^2 \vec{p}` lies on this line.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera.Default(pose=SE3(0.1, 0.05, 0), name=&#39;camera2&#39;)</span>
<span class="sd">            &gt;&gt;&gt; P = [-0.2, 0.3, 5]  # world point</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)  # project to first camera</span>
<span class="sd">            &gt;&gt;&gt; camera2.plot_point(P, &#39;kd&#39;) # project and display in second camera</span>
<span class="sd">            &gt;&gt;&gt; camera2.plot_epiline(camera1.F(camera2), p1) # plot epipolar line in second camera</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.2.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`plot_point` :meth:`epiline` :meth:`CentralCamera.F`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># p is 3 x N, result is 3 x N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_line2</span><span class="p">(</span><span class="n">F</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.plot_line3"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.plot_line3">[docs]</a>    <span class="k">def</span> <span class="nf">plot_line3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot 3D line on virtual image plane (base method)</span>

<span class="sd">        :param L: 3D line in Plucker coordinates</span>
<span class="sd">        :type L: :class:`~spatialmath..geom3d.Line3`</span>
<span class="sd">        :param kwargs: arguments passed to ``plot``</span>

<span class="sd">        The Plucker line is projected to the camera&#39;s virtual image plane and</span>
<span class="sd">        plotted.</span>

<span class="sd">        .. note::</span>
<span class="sd">            - Successive calls add items to the virtual image plane.</span>
<span class="sd">            - This method is common to all ``CameraBase`` subclasses, but it</span>
<span class="sd">              invokes a camera-specific projection method.</span>
<span class="sd">              </span>
<span class="sd">        :seealso: :meth:`plot_point` :meth:`plot_line2` :meth:`plot_wireframe` :meth:`clf`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_line</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hl</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_line2</span><span class="p">(</span><span class="n">hl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.ray"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.ray">[docs]</a>    <span class="k">def</span> <span class="nf">ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project image plane points to a ray</span>

<span class="sd">        :param points: image plane points</span>
<span class="sd">        :type points: ndarray(2,N)</span>
<span class="sd">        :param pose: camera pose, defaults to None</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :return: corresponding Plucker lines</span>
<span class="sd">        :rtype: :class:`~spatialmath..geom3d.Line3`</span>

<span class="sd">        For each image plane point compute the equation of a Plucker line</span>
<span class="sd">        that represents the 3D ray from the camera origin through the image</span>
<span class="sd">        plane point.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; line = camera.ray((100, 200))</span>
<span class="sd">            &gt;&gt;&gt; line</span>

<span class="sd">        :reference:</span>
<span class="sd">            - &quot;Multiview Geometry&quot;, Hartley &amp; Zisserman, p.162</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.3, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`~spatialmath..geom3d.Line3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define Plucker line in terms of point (centre of camera) and direction</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">(</span><span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">)</span>
        <span class="n">Mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Line3</span><span class="o">.</span><span class="n">PointDir</span><span class="p">(</span><span class="o">-</span><span class="n">Mi</span> <span class="o">@</span> <span class="n">v</span><span class="p">,</span> <span class="n">Mi</span> <span class="o">@</span> <span class="n">smbase</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">point</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Line3</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Position of camera frame</span>

<span class="sd">        :return: Euclidean coordinate of the camera frame&#39;s origin</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera.Default(name=&#39;camera1&#39;, pose=SE3.Trans(1,2,3))</span>
<span class="sd">            &gt;&gt;&gt; camera1</span>
<span class="sd">            &gt;&gt;&gt; camera1.centre</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">t</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Position of camera frame</span>

<span class="sd">        :return: Euclidean coordinate of the camera frame&#39;s origin</span>
<span class="sd">        :rtype: ndarray(3)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera.Default(name=&#39;camera1&#39;, pose=SE3.Trans(1,2,3))</span>
<span class="sd">            &gt;&gt;&gt; camera1</span>
<span class="sd">            &gt;&gt;&gt; camera1.center</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">t</span>

<div class="viewcode-block" id="CentralCamera.fov"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.fov">[docs]</a>    <span class="k">def</span> <span class="nf">fov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Camera field-of-view angles</span>

<span class="sd">        :return: field of view angles in radians</span>
<span class="sd">        :rtype: ndarray(2)</span>
<span class="sd">        </span>
<span class="sd">        Computes the field of view angles (2x1) in radians for the camera</span>
<span class="sd">        horizontal and vertical directions.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera1.fov()</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1.4, P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;imagesize or rho properties not set&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.distort"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.distort">[docs]</a>    <span class="k">def</span> <span class="nf">distort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute distorted coordinate</span>

<span class="sd">        :param points: image plane points</span>
<span class="sd">        :type points: ndarray(2,n)</span>
<span class="sd">        :returns: distorted image plane coordinates</span>
<span class="sd">        :rtype: ndarray(2,n)</span>
<span class="sd">        </span>
<span class="sd">        Compute the image plane coordinates after lens distortion has been</span>
<span class="sd">        applied.  The lens distortion model is initialized at constructor time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>

        <span class="c1"># convert to normalized image coordinates</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span> <span class="o">*</span> <span class="n">smbase</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="c1"># unpack coordinates</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># unpack distortion vector</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># distance from principal point</span>
        
        <span class="c1"># compute the shift due to distortion</span>
        <span class="n">delta_u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> \
            <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">delta_v</span> <span class="o">=</span> <span class="n">v</span>  <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> \
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>  <span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span>
        
        <span class="c1"># distorted coordinates</span>
        <span class="n">ud</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">delta_u</span>
        <span class="n">vd</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">delta_v</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="n">smbase</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ud</span><span class="p">,</span> <span class="n">vd</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># convert to pixel coords</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get focal length in horizontal direction</span>

<span class="sd">        :return: focal length in horizontal direction</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.fu</span>

<span class="sd">        :seealso: :meth:`fv` :meth:`f`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fu</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get focal length in vertical direction</span>

<span class="sd">        :return: focal length in vertical direction</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.fv</span>

<span class="sd">        :seealso: :meth:`fu` :meth:`f`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/get focal length</span>

<span class="sd">        :return: focal length in horizontal and vertical directions</span>
<span class="sd">        :rtype: ndarray(2)</span>

<span class="sd">        Return focal length in horizontal and vertical directions.  </span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.f</span>
<span class="sd">            &gt;&gt;&gt; camera.f = 0.015</span>
<span class="sd">            &gt;&gt;&gt; camera.f</span>
<span class="sd">            &gt;&gt;&gt; camera.f = [0.015, 0.020]</span>
<span class="sd">            &gt;&gt;&gt; camera.f</span>

<span class="sd">        .. note:: These are normally identical but will differ if the sensor</span>
<span class="sd">            has non-square pixels or the frame grabber is changing the aspect </span>
<span class="sd">            ratio of the image.</span>

<span class="sd">        :seealso: :meth:`fu` :meth:`fv`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fv</span><span class="p">]</span>

    <span class="nd">@f</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;[summary]</span>

<span class="sd">        :param f: focal length</span>
<span class="sd">        :type f: scalar or array_like(2)</span>
<span class="sd">        :raises ValueError: incorrect length of ``f``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fu</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fv</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fu</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fv</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;f must be a 1- or 2-element vector&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fpix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get focal length in pixels</span>

<span class="sd">        :return: focal length in horizontal and vertical directions in pixels</span>
<span class="sd">        :rtype: ndarray(2)</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.fpix</span>

<span class="sd">        :seealso: :meth:`f`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhou</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhov</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intrinsic matrix of camera</span>

<span class="sd">        :return: intrinsic matrix</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        Return the camera intrinsic matrix.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.K</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`pp` :meth:`rho`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fmt: off</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">fu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhou</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                   <span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>                  <span class="bp">self</span><span class="o">.</span><span class="n">fv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>                  <span class="mi">0</span><span class="p">,</span>                    <span class="mi">1</span><span class="p">]</span>
                      <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># fmt: on</span>
        <span class="k">return</span> <span class="n">K</span>

    <span class="c1"># =================== camera calibration =============================== #</span>
<div class="viewcode-block" id="CentralCamera.C"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.C">[docs]</a>    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retinal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Camera projection matrix</span>

<span class="sd">        :param T: camera pose with respect to world frame, defaults to pose from camera object</span>
<span class="sd">        :type T: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param retinal: transform to retinal coordinates, default False</span>
<span class="sd">        :type retinal: bool, optional</span>
<span class="sd">        :return: camera projection/calibration matrix</span>
<span class="sd">        :rtype: ndarray(3,4)</span>

<span class="sd">        Return the camera matrix which projects 3D points to the image plane.</span>
<span class="sd">        It is a function of the camera&#39;s intrinsic and extrinsic parameters.</span>

<span class="sd">        If ``retinal`` is True then project points in retinal coordinates, </span>
<span class="sd">        in units of metres with respect to the principal point.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; camera.C()</span>
<span class="sd">            &gt;&gt;&gt; camera.C(SE3.Trans(0.1, 0, 0))</span>
<span class="sd">            &gt;&gt;&gt; camera.move(SE3(0.1, 0, 0)).C()</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :meth:`project_point` :meth:`K` :meth:`decomposeC`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>
        <span class="k">if</span> <span class="n">retinal</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fv</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
        <span class="k">return</span> <span class="n">K</span> <span class="o">@</span> <span class="n">P0</span> <span class="o">@</span> <span class="n">pose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">A</span></div>

<div class="viewcode-block" id="CentralCamera.points2C"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.points2C">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">points2C</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate camera matrix from data points</span>

<span class="sd">        :param P: calibration points in world coordinate frame</span>
<span class="sd">        :type P: ndarray(3,N)</span>
<span class="sd">        :param p: calibration points in image plane</span>
<span class="sd">        :type p: ndarray(2,N)</span>
<span class="sd">        :return: camera calibration matrix and residual</span>
<span class="sd">        :rtype: ndarray(3,4), float</span>

<span class="sd">        Estimate the camera matrix :math:`\mat{C}` determined by least</span>
<span class="sd">        squares from corresponding world ``P`` and image-plane ``p`` points.</span>
<span class="sd">        Corresponding points are represented by corresponding columns of ``P``</span>
<span class="sd">        and ``p``.  Also returns the residual which is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \max | \mat{C}\mat{P} - \mat{p} |</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkcube</span>
<span class="sd">            &gt;&gt;&gt; P = mkcube(0.2)</span>
<span class="sd">            &gt;&gt;&gt; camera_unknown = CentralCamera(f=0.015, rho=10e-6, imagesize=[1280, 1024], noise=0.05, seed=0)</span>
<span class="sd">            &gt;&gt;&gt; T_unknown = SE3.Trans(0.1, 0.2, 1.5) * SE3.RPY(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; p = camera_unknown.project_point(P, objpose=T_unknown)</span>
<span class="sd">            &gt;&gt;&gt; C, resid = CentralCamera.points2C(P, p)</span>
<span class="sd">            &gt;&gt;&gt; C</span>
<span class="sd">            &gt;&gt;&gt; camera_unknown.C()</span>
<span class="sd">            &gt;&gt;&gt; resid</span>

<span class="sd">        .. note:: This method assumes no lens distortion affecting the image plane</span>
<span class="sd">            coordinates.</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.2.1, P. Corke, </span>
<span class="sd">              Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`images2C` :meth:`decomposeC`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">uv</span><span class="p">,</span> <span class="n">X</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">uv</span>
            <span class="c1"># fmt: off</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span> <span class="n">X</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z4</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span> <span class="o">*</span> <span class="n">X</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">z4</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span> <span class="o">*</span> <span class="n">X</span><span class="p">]</span>
                <span class="p">])</span>
            <span class="c1"># fmt: on</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">uv</span><span class="p">]</span>

        <span class="c1"># solve Ax = b where c is 11 elements of camera matrix</span>
        <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="c1"># compute and print the residual</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span><span class="p">)))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>   <span class="c1"># append a 1</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  <span class="c1"># make a 3x4 matrix</span>

        <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">r</span></div>

<div class="viewcode-block" id="CentralCamera.images2C"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.images2C">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">images2C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">gridshape</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">squaresize</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calibrate camera from checkerboard images</span>

<span class="sd">        :param images: an iterator that returns :class:`~machinevisiontoolbox.ImageCore.Image` objects</span>
<span class="sd">        :type images: :class:`~machinevisiontoolbox.Sources.ImageSource`</span>
<span class="sd">        :param gridshape: number of grid squares in each dimension, defaults to (7,6)</span>
<span class="sd">        :type gridshape: tuple, optional</span>
<span class="sd">        :param squaresize: size of the grid squares in units of length, defaults to 0.025</span>
<span class="sd">        :type squaresize: float, optional</span>
<span class="sd">        :return: camera calibration matrix, distortion parameters, image frames</span>
<span class="sd">        :rtype: ndarray(3,4), ndarray(5), list of named tuples</span>

<span class="sd">        The distortion coefficients are in the order :math:`(k_1, k_2, p_1, p_2, k_3)`</span>
<span class="sd">        where :math:`k_i` are radial distortion coefficients and :math:`p_i` are</span>
<span class="sd">        tangential distortion coefficients.</span>

<span class="sd">        Image frames that were successfully processed are returned as a list of</span>
<span class="sd">        named tuples ``CalibrationFrame`` with elements:</span>

<span class="sd">        =======  =====================  ===========================================================</span>
<span class="sd">        element  type                   description</span>
<span class="sd">        =======  =====================  ===========================================================</span>
<span class="sd">        image    :class:`Image`         calibration image with overlaid annotation</span>
<span class="sd">        pose     :class:`SE3` instance  pose of the camera with respect to the origin of this image</span>
<span class="sd">        id       int                    sequence number of this image in ``images``</span>
<span class="sd">        =======  =====================  ===========================================================</span>

<span class="sd">        .. note:: The units used for ``squaresize`` must match the units used</span>
<span class="sd">            for defining 3D points in space.</span>

<span class="sd">        :references:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.7, P. Corke, </span>
<span class="sd">              Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`points2C` :meth:`decomposeC` :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">criteria</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">TERM_CRITERIA_EPS</span> <span class="o">+</span> <span class="n">cv</span><span class="o">.</span><span class="n">TERM_CRITERIA_MAX_ITER</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="c1"># create set of feature points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)</span>
        <span class="c1"># these all have Z=0 since they are relative to the calibration target frame</span>
        <span class="n">objp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">gridshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gridshape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">objp</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">gridshape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">gridshape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">squaresize</span>

        <span class="c1"># lists to store object points and image points from all the images</span>
        <span class="n">objpoints</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 3d point in real world space</span>
        <span class="n">imgpoints</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># 2d points in image plane.</span>
        <span class="n">corner_images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>

            <span class="n">gray</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span><span class="o">.</span><span class="n">A</span>
            <span class="c1"># Find the chess board corners</span>
            <span class="n">ret</span><span class="p">,</span> <span class="n">corners</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">findChessboardCorners</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">gridshape</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># If found, add object points, image points (after refining them)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
                <span class="n">objpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objp</span><span class="p">)</span>
                <span class="n">corners2</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">cornerSubPix</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span><span class="n">corners</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">criteria</span><span class="p">)</span>
                <span class="n">imgpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                <span class="c1"># Draw the corners</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">image</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">colorize</span><span class="p">()</span>
                <span class="n">corner_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv</span><span class="o">.</span><span class="n">drawChessboardCorners</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">gridshape</span><span class="p">,</span> <span class="n">corners2</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
                <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">ret</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">distortion</span><span class="p">,</span> <span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">calibrateCamera</span><span class="p">(</span><span class="n">objpoints</span><span class="p">,</span> <span class="n">imgpoints</span><span class="p">,</span> <span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">CalibrationFrame</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;CalibrationFrame&quot;</span><span class="p">,</span> <span class="s2">&quot;image pose id&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span><span class="p">,</span> <span class="n">corner_image</span><span class="p">,</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rvecs</span><span class="p">,</span> <span class="n">tvecs</span><span class="p">,</span> <span class="n">corner_images</span><span class="p">,</span> <span class="n">valid</span><span class="p">):</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">CalibrationFrame</span><span class="p">(</span>
                    <span class="n">Image</span><span class="p">(</span><span class="n">corner_image</span><span class="p">,</span> <span class="n">colororder</span><span class="o">=</span><span class="s2">&quot;BGR&quot;</span><span class="p">),</span> 
                    <span class="p">(</span><span class="n">SE3</span><span class="p">(</span><span class="n">tvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">SE3</span><span class="o">.</span><span class="n">EulerVec</span><span class="p">(</span><span class="n">rvec</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span><span class="o">.</span><span class="n">inv</span><span class="p">(),</span>
                    <span class="nb">id</span><span class="p">)</span>
                <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">distortion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CentralCamera.decomposeC"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.decomposeC">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">decomposeC</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose camera calibration matrix</span>

<span class="sd">        :param C: camera calibration matrix</span>
<span class="sd">        :type C: ndarray(3,4)</span>
<span class="sd">        :return: camera model parameters</span>
<span class="sd">        :rtype: :class:`CentralCamera`</span>

<span class="sd">        Decompose a :math:`3\times 4` camera calibration matrix ``C`` to</span>
<span class="sd">        determine feasible intrinsic and extrinsic parameters. The result is a</span>
<span class="sd">        ``CentralCamera`` instance with the following parameters set:</span>

<span class="sd">        ================  ====================================</span>
<span class="sd">        Parameter         Meaning</span>
<span class="sd">        ================  ====================================</span>
<span class="sd">        ``f``             focal length in pixels</span>
<span class="sd">        ``sx``, ``sy``    pixel size where ``sx`` =1</span>
<span class="sd">        (``u0``, ``v0``)  principal point</span>
<span class="sd">        ``pose``          pose of the camera frame wrt world</span>
<span class="sd">        ================  ====================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera(name=&#39;camera1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; C = camera.C(SE3(0.1, 0, 0))</span>
<span class="sd">            &gt;&gt;&gt; CentralCamera.decomposeC(C)</span>

<span class="sd">        .. note:: Since only :math:`f s_x` and :math:`f s_y` can be estimated we</span>
<span class="sd">            set :math:`s_x = 1`.</span>

<span class="sd">        :reference:</span>
<span class="sd">            - Multiple View Geometry, Hartley&amp;Zisserman, p 163-164</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.2.3, P. Corke, </span>
<span class="sd">              Springer 2023.</span>

<span class="sd">        :seealso: :meth:`C` :meth:`points2C`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">rq</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="c1"># from vgg_rq.m</span>
            <span class="c1"># [R,Q] = vgg_rq(S)  Just like qr but the other way around.</span>
            <span class="c1"># If [R,Q] = vgg_rq(X), then R is upper-triangular, Q is orthogonal, and X==R*Q.</span>
            <span class="c1"># Moreover, if S is a real matrix, then det(Q)&gt;0.</span>
            <span class="c1"># By awf</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Q</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">S</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">Q</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;argument is not a 3x4 matrix&#39;</span><span class="p">)</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># determine camera position</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># last column</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># determine camera orientation</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># K, R = rq(M)</span>
        <span class="n">K</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">rq</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="c1"># deal with K having negative elements on the diagonal</span>
        <span class="c1"># make a matrix to fix this, K*C has positive diagonal</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">K</span><span class="p">)))</span>
        
        <span class="c1"># now  K*R = (K*C) * (inv(C)*R), so we need to check C is a proper rotation</span>
        <span class="c1"># matrix.  If isn&#39;t then the situation is unfixable</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">C</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;cannot correct signs in the intrinsic matrix&#39;</span><span class="p">)</span>
        
        <span class="c1"># all good, let&#39;s fix it</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">@</span> <span class="n">C</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">R</span>
        
        <span class="c1"># normalize K so that lower left is 1</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">/</span> <span class="n">K</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># pull out focal length and scale factors</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># build an equivalent camera model</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;invC&#39;</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">pp</span><span class="o">=</span><span class="n">K</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">rho</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span></div>

<span class="c1"># https://docs.opencv.org/3.1.0/d9/d0c/group__calib3d.html#gaaae5a7899faa1ffdf268cd9088940248</span>

    <span class="c1"># ======================= homography =============================== #</span>

<div class="viewcode-block" id="CentralCamera.H"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.H">[docs]</a>    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute homography from plane and camera pose</span>

<span class="sd">        :param T: relative camera motion</span>
<span class="sd">        :type T: :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        :param n: plane normal with respect to world frame</span>
<span class="sd">        :type n: array_like(3)</span>
<span class="sd">        :param d: plane offset from world frame origin</span>
<span class="sd">        :type d: float</span>
<span class="sd">        :return: homography matrix</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        Computes the homography matrix for the camera observing points on a</span>
<span class="sd">        plane from two viewpoints. The first view is from the current camera</span>
<span class="sd">        pose (``self.pose``), and the second is after a relative motion</span>
<span class="sd">        represented by the rigid-body motion ``T``. The plane has normal ``n``</span>
<span class="sd">        and at distance ``d`` with respect to the world frame.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default(name=&#39;camera1&#39;) # looking along z-axis</span>
<span class="sd">            &gt;&gt;&gt; plane = [0, 1, 1]</span>
<span class="sd">            &gt;&gt;&gt; H = camera.H(SE3.Tx(0.2), plane, 5)</span>
<span class="sd">            &gt;&gt;&gt; H</span>

<span class="sd">        :seealso: :meth:`points2H` :meth:`decomposeH`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;plane distance d must be &gt; 0&#39;</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;normal must be away from camera (n[2] &gt;= 0)&#39;</span><span class="p">)</span>

        <span class="c1"># T transform view 1 to view 2</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

        <span class="n">HH</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">t</span> <span class="o">@</span> <span class="n">n</span>  <span class="c1"># need to ensure column then row = 3x3</span>

        <span class="c1"># apply camera intrinsics</span>
        <span class="n">HH</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">@</span> <span class="n">HH</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">HH</span> <span class="o">/</span> <span class="n">HH</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># normalised</span></div>

<div class="viewcode-block" id="CentralCamera.points2H"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.points2H">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">points2H</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsquares&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate homography from corresponding points</span>

<span class="sd">        :param p1: image plane points from first camera</span>
<span class="sd">        :type p1: ndarray(2,N)</span>
<span class="sd">        :param p2: image plane points from second camera</span>
<span class="sd">        :type p2: ndarray(2,N)</span>
<span class="sd">        :param method: algorithm: &#39;leastsquares&#39; [default], &#39;ransac&#39;, &#39;lmeds&#39;, &#39;prosac&#39;</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param kwargs: optional arguments as required for ransac&#39; and &#39;lmeds&#39;</span>
<span class="sd">            methods</span>
<span class="sd">        :return: homography, residual and optional inliers</span>
<span class="sd">        :rtype: ndarray(3,3), float, ndarray(N,bool)</span>

<span class="sd">        Compute a homography from two sets of corresponding image plane points</span>
<span class="sd">        whose world points lie on a plane.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkgrid</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(-0.1)*SE3.Ry(0.4))</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera(name=&quot;camera 2&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(0.1)*SE3.Ry(-0.4))</span>
<span class="sd">            &gt;&gt;&gt; T_grid = SE3.Tz(1) * SE3.Rx(0.1) * SE3.Ry(0.2)</span>
<span class="sd">            &gt;&gt;&gt; P = mkgrid(3, 1.0, pose=T_grid)</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)</span>
<span class="sd">            &gt;&gt;&gt; p2 = camera2.project_point(P);</span>
<span class="sd">            &gt;&gt;&gt; H, resid = CentralCamera.points2H(p1, p2)</span>
<span class="sd">            &gt;&gt;&gt; H</span>
<span class="sd">            &gt;&gt;&gt; resid</span>

<span class="sd">        .. note:: If the method is &#39;ransac&#39; or &#39;lmeds&#39; then a boolean array</span>
<span class="sd">            of inliers is also returned, True means the corresponding input</span>
<span class="sd">            point pair is an inlier.</span>

<span class="sd">        :reference:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.2.4, P. Corke, </span>
<span class="sd">              Springer 2023.</span>

<span class="sd">        :seealso: :meth:`H` :meth:`decomposeH` </span>
<span class="sd">            `opencv.findHomography &lt;https://docs.opencv.org/master/d9/d0c/group__calib3d.html#ga4abc2ece9fab9398f2e560d53c8c9780&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">points2H_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;leastsquares&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;ransac&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span>
            <span class="s1">&#39;lmeds&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">LMEDS</span><span class="p">,</span>
            <span class="s1">&#39;prosac&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">RHO</span> 
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cv</span><span class="o">.</span><span class="n">setRNGSeed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">H</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">findHomography</span><span class="p">(</span>
            <span class="n">srcPoints</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">dstPoints</span><span class="o">=</span><span class="n">p2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">points2H_dict</span><span class="p">[</span><span class="n">method</span><span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">homtrans</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">])</span> <span class="o">-</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ransac&#39;</span><span class="p">,</span> <span class="s1">&#39;lmeds&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">resid</span></div>

    <span class="c1"># https://docs.opencv.org/3.1.0/d9/d0c/group__calib3d.html#ga7f60bdff78833d1e3fd6d9d0fd538d92</span>
<div class="viewcode-block" id="CentralCamera.decomposeH"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.decomposeH">[docs]</a>    <span class="k">def</span> <span class="nf">decomposeH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose homography matrix</span>

<span class="sd">        :param H: homography matrix</span>
<span class="sd">        :type H: ndarray(3,3)</span>
<span class="sd">        :param K: camera intrinsics, defaults to parameters from object</span>
<span class="sd">        :type K: ndarray(3,3), optional</span>
<span class="sd">        :return: camera poses, plane normals</span>
<span class="sd">        :rtype: :class:`~spatialmath..pose3d.SE3`, list of ndarray(3,1)</span>

<span class="sd">        Decomposes the homography matrix into the camera motion and the normal</span>
<span class="sd">        to the plane. In practice, there are multiple solutions. The translation</span>
<span class="sd">        not to scale.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkgrid</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(-0.1)*SE3.Ry(0.4))</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera(name=&quot;camera 2&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(0.1)*SE3.Ry(-0.4))</span>
<span class="sd">            &gt;&gt;&gt; T_grid = SE3.Tz(1) * SE3.Rx(0.1) * SE3.Ry(0.2)</span>
<span class="sd">            &gt;&gt;&gt; P = mkgrid(3, 1.0, pose=T_grid)</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)</span>
<span class="sd">            &gt;&gt;&gt; p2 = camera2.project_point(P);</span>
<span class="sd">            &gt;&gt;&gt; H, resid = CentralCamera.points2H(p1, p2)</span>
<span class="sd">            &gt;&gt;&gt; T, normals = camera1.decomposeH(H)</span>
<span class="sd">            &gt;&gt;&gt; T.printline(orient=&quot;camera&quot;)</span>
<span class="sd">            &gt;&gt;&gt; normals</span>

<span class="sd">        :reference:</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.2.4, P. Corke, </span>
<span class="sd">              Springer 2023.</span>

<span class="sd">        :seealso: :meth:`points2H` :meth:`H`</span>
<span class="sd">            `opencv.decomposeHomographyMat &lt;&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">retval</span><span class="p">,</span> <span class="n">rotations</span><span class="p">,</span> <span class="n">translations</span><span class="p">,</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">decomposeHomographyMat</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="n">translations</span><span class="p">):</span>
            <span class="c1"># we normalize the rotation matrix, those returned by openCV can</span>
            <span class="c1"># not quite proper SO(3) values</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">smbase</span><span class="o">.</span><span class="n">trnorm</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
            <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pose</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">normals</span></div>

        <span class="c1"># if K is None:</span>
        <span class="c1">#     K = np.identity(3)</span>
        <span class="c1">#     # also have K = self.K</span>

        <span class="c1"># H = np.linalg.inv(K) @ H @ K</span>

        <span class="c1"># # normalise so that the second singular value is one</span>
        <span class="c1"># U, S, V = np.linalg.svd(H, compute_uv=True)</span>
        <span class="c1"># H = H / S[1]</span>

        <span class="c1"># # compute the SVD of the symmetric matrix H&#39;*H = VSV&#39;</span>
        <span class="c1"># U, S, V = np.linalg.svd(np.transpose(H) @ H)</span>

        <span class="c1"># # ensure V is right-handed</span>
        <span class="c1"># if np.linalg.det(V) &lt; 0:</span>
        <span class="c1">#     print(&#39;det(V) was &lt; 0&#39;)</span>
        <span class="c1">#     V = -V</span>

        <span class="c1"># # get squared singular values</span>
        <span class="c1"># s0 = S[0]</span>
        <span class="c1"># s2 = S[2]</span>

        <span class="c1"># # v0 = V[0:, 0]</span>
        <span class="c1"># # v1 = V[0:, 1]</span>
        <span class="c1"># # v2 = V[0:, 2]</span>

        <span class="c1"># # pure rotation - where all singular values == 1</span>
        <span class="c1"># if np.abs(s0 - s2) &lt; (100 * np.spacing(1)):</span>
        <span class="c1">#     print(&#39;Warning: Homography due to pure rotation&#39;)</span>
        <span class="c1">#     if np.linalg.det(H) &lt; 0:</span>
        <span class="c1">#         H = -H</span>
        <span class="c1">#     # sol = namedtuple(&#39;T&#39;, T, &#39;&#39;</span>
        <span class="c1"># # TODO finish from invhomog.m</span>
        <span class="c1"># print(&#39;Unfinished&#39;)</span>
        <span class="c1"># return False</span>


    <span class="c1"># =================== fundamental matrix =============================== #</span>

<div class="viewcode-block" id="CentralCamera.F"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.F">[docs]</a>    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fundamental matrix</span>

<span class="sd">        :param other: second camera view</span>
<span class="sd">        :type other: :class:`CentralCamera`, :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        :return: fundamental matrix</span>
<span class="sd">        :rtype: numpy(3,3)</span>

<span class="sd">        Compute the fundamental matrix relating two camera views.  The</span>
<span class="sd">        first view is defined by the instance.  The second</span>
<span class="sd">        is defined by:</span>
<span class="sd">        </span>
<span class="sd">        * another :class:`CentralCamera` instance</span>
<span class="sd">        * an SE3 pose describing the pose of the second view with respect to </span>
<span class="sd">          the first, assuming the same camera intrinsic parameters.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(-0.1)*SE3.Ry(0.4))</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera(name=&quot;camera 2&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(0.1)*SE3.Ry(-0.4))</span>
<span class="sd">            &gt;&gt;&gt; F = camera1.F(camera2)</span>
<span class="sd">            &gt;&gt;&gt; F</span>
<span class="sd">            &gt;&gt;&gt; F = camera1.F(SE3.Tx(0.2))</span>
<span class="sd">            &gt;&gt;&gt; F</span>

<span class="sd">        :reference:</span>
<span class="sd">            - Y.Ma, J.Kosecka, S.Soatto, S.Sastry, &quot;An invitation to 3D&quot;,</span>
<span class="sd">              Springer, 2003. p.177</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 14.2.1, P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`points2F` :meth:`E`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">E</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CentralCamera</span><span class="p">):</span>
            <span class="c1"># use relative pose and camera parameters of </span>
            <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">K1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
            <span class="n">K2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">K</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">E</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad type&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.points2F"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.points2F">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">points2F</span><span class="p">(</span>
                    <span class="n">p1</span><span class="p">,</span>
                    <span class="n">p2</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;8p&#39;</span><span class="p">,</span>
                    <span class="n">residual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate fundamental matrix from corresponding points</span>

<span class="sd">        :param p1: image plane points from first camera</span>
<span class="sd">        :type p1: ndarray(2,N)</span>
<span class="sd">        :param p2: image plane points from second camera</span>
<span class="sd">        :type p2: ndarray(2,N)</span>
<span class="sd">        :param method: algorithm &#39;7p&#39;, &#39;8p&#39; [default], &#39;ransac&#39;, &#39;lmeds&#39;</span>
<span class="sd">        :type method: str, optional</span>
<span class="sd">        :param kwargs: optional arguments as required for ransac&#39;, &#39;lmeds&#39;</span>
<span class="sd">            methods</span>
<span class="sd">        :return: fundamental matrix and residual</span>
<span class="sd">        :rtype: ndarray(3,3), float</span>

<span class="sd">        Computes the fundamental matrix from two sets of corresponding</span>
<span class="sd">        image-plane points. Corresponding points are given by corresponding</span>
<span class="sd">        columns of ``p1`` and ``p2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkgrid</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(-0.1)*SE3.Ry(0.4))</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera(name=&quot;camera 2&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(0.1)*SE3.Ry(-0.4))</span>
<span class="sd">            &gt;&gt;&gt; T_grid = SE3.Tz(1) * SE3.Rx(0.1) * SE3.Ry(0.2)</span>
<span class="sd">            &gt;&gt;&gt; P = mkgrid(3, 1.0, pose=T_grid)</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)</span>
<span class="sd">            &gt;&gt;&gt; p2 = camera2.project_point(P);</span>
<span class="sd">            &gt;&gt;&gt; F, resid = CentralCamera.points2F(p1, p2)</span>
<span class="sd">            &gt;&gt;&gt; F</span>
<span class="sd">            &gt;&gt;&gt; resid</span>

<span class="sd">        :seealso: :meth:`F` :meth:`E`</span>
<span class="sd">            `opencv.findFundamentalMat &lt;https://docs.opencv.org/master/d9/d0c/group__calib3d.html#ga59b0d57f46f8677fb5904294a23d404a&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">points2F_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;7p&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">FM_7POINT</span><span class="p">,</span>
                <span class="s1">&#39;8p&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">FM_8POINT</span><span class="p">,</span>
                <span class="s1">&#39;ransac&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">FM_RANSAC</span><span class="p">,</span>
                <span class="s1">&#39;lmeds&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">FM_LMEDS</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cv</span><span class="o">.</span><span class="n">setRNGSeed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">F</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">findFundamentalMat</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="n">points2F_dict</span><span class="p">[</span><span class="n">method</span><span class="p">],</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="c1"># add various return values</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">residual</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p2</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">F</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p1</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">])</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ransac&#39;</span><span class="p">,</span> <span class="s1">&#39;lmeds&#39;</span><span class="p">):</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retval</span></div>
        <span class="c1"># elines = base.e2h(p2).T @ F # homog lines, one per row</span>
        <span class="c1"># p1h = base.e2h(p1)</span>
        <span class="c1"># residuals = []</span>
        <span class="c1"># for i, line in enumerate(elines):</span>
        <span class="c1">#     d = line @ p1h[:, i] / np.sqrt(line[0] ** 2 + line[1] ** 2)</span>
        <span class="c1">#     residuals.append(d)</span>
        <span class="c1"># resid = np.array(residuals).mean()</span>

        
<div class="viewcode-block" id="CentralCamera.epidist"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.epidist">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">epidist</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Epipolar distance</span>

<span class="sd">        :param F: fundamental matrix</span>
<span class="sd">        :type F: ndarray(3,3)</span>
<span class="sd">        :param p1: image plane point or points from first camera</span>
<span class="sd">        :type p1: ndarray(2) or ndarray(2,N)</span>
<span class="sd">        :param p2: image plane point or points from second camera</span>
<span class="sd">        :type p2: ndarray(2) or ndarray(2,M)</span>
<span class="sd">        :return: distance matrix</span>
<span class="sd">        :rtype: ndarray(N,M)</span>

<span class="sd">        Computes the distance of the points ``p2`` from the </span>
<span class="sd">        epipolar lines induced by points ``p1``.  Element [i,j] of the return</span>
<span class="sd">        value is the istance of point j in camera 2 from the epipolar line</span>
<span class="sd">        induced by point i in camera 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">p1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># compute epipolar lines corresponding to p1</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">F</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> \
                    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">D</span></div>

    <span class="c1"># ===================== essential matrix =============================== #</span>

<div class="viewcode-block" id="CentralCamera.E"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.E">[docs]</a>    <span class="k">def</span> <span class="nf">E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Essential matrix from two camera views</span>

<span class="sd">        :param other: second camera view, camera pose or fundamental matrix</span>
<span class="sd">        :type other: :class:`CentralCamera`, :class:`~spatialmath..pose3d.SE3`, ndarray(3,3)</span>
<span class="sd">        :return: essential matrix</span>
<span class="sd">        :rtype: ndarray(3,3)</span>

<span class="sd">        Compute the essential matrix relating two camera views. The first view</span>
<span class="sd">        is defined by the instance, and second view is specified by:</span>

<span class="sd">        * a camera instance represented by a :class:`CentralCamera`. Assumes the</span>
<span class="sd">          cameras have the same intrinsics.</span>
<span class="sd">        * a relative motion represented by a :class:`~spatialmath..pose3d.SE3`</span>
<span class="sd">        * a fundamental matrix</span>
<span class="sd">        </span>
<span class="sd">        :reference:</span>
<span class="sd">            - Y.Ma, J.Kosecka, S.Soatto, S.Sastry, &quot;An invitation to 3D&quot;,</span>
<span class="sd">              Springer, 2003. p.177</span>

<span class="sd">        :seealso: :meth:`F` :meth:`decomposeE` :meth:`points2E`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># essential matrix from F matrix and intrinsics</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">other</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CentralCamera</span><span class="p">):</span>
            <span class="c1"># camera relative pose</span>
            <span class="n">T21</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="c1"># relative pose given explicitly</span>
            <span class="n">T21</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad type&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">T21</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">@</span> <span class="n">T21</span><span class="o">.</span><span class="n">R</span></div>

<div class="viewcode-block" id="CentralCamera.points2E"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.points2E">[docs]</a>    <span class="k">def</span> <span class="nf">points2E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">p1</span><span class="p">,</span>
                    <span class="n">p2</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Essential matrix from points</span>

<span class="sd">        :param P1: image plane points</span>
<span class="sd">        :type P1: ndarray(2,N)</span>
<span class="sd">        :param P2: image plane points</span>
<span class="sd">        :type P2: ndarray(2,N)</span>
<span class="sd">        :param method: method, can be &#39;ransac&#39; or &#39;lmeds&#39;</span>
<span class="sd">        :type method: str</span>
<span class="sd">        :param K: camera intrinsic matrix, defaults to that of camera object</span>
<span class="sd">        :type K: ndarray(3,3), optional</span>
<span class="sd">        :param kwargs: additional arguments required for &#39;ransac&#39; or &#39;lmeds&#39;</span>
<span class="sd">            options</span>
<span class="sd">        :return: essential matrix and optional inlier vevtor</span>
<span class="sd">        :rtype: ndarray(3,3), ndarray(N, bool)</span>

<span class="sd">        Compute the essential matrix from two sets of corresponding points.</span>
<span class="sd">        Each set of points is represented by the columns of the array ``p1``</span>
<span class="sd">        or ``p2``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera, mkgrid</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(-0.1)*SE3.Ry(0.4))</span>
<span class="sd">            &gt;&gt;&gt; camera2 = CentralCamera(name=&quot;camera 2&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=SE3.Tx(0.1)*SE3.Ry(-0.4))</span>
<span class="sd">            &gt;&gt;&gt; T_grid = SE3.Tz(1) * SE3.Rx(0.1) * SE3.Ry(0.2)</span>
<span class="sd">            &gt;&gt;&gt; P = mkgrid(3, 1.0, pose=T_grid)</span>
<span class="sd">            &gt;&gt;&gt; p1 = camera1.project_point(P)</span>
<span class="sd">            &gt;&gt;&gt; p2 = camera2.project_point(P);</span>
<span class="sd">            &gt;&gt;&gt; E, inliers = camera1.points2E(p1, p2)</span>
<span class="sd">            &gt;&gt;&gt; E</span>
<span class="sd">            &gt;&gt;&gt; inliers</span>

<span class="sd">        .. note:: If the method is &#39;ransac&#39; or &#39;lmeds&#39; then a boolean array</span>
<span class="sd">            of inliers is also returned, True means the corresponding input</span>
<span class="sd">            point pair is an inlier.</span>

<span class="sd">        :seealso: :meth:`E` :meth:`decomposeE` </span>
<span class="sd">            `opencv.findEssentialMat &lt;https://docs.opencv.org/master/d9/d0c/group__calib3d.html#gad245d60e64d0c1270dbfd0520847bb87&gt;`_</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="n">points2E_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;ransac&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">RANSAC</span><span class="p">,</span>
            <span class="s1">&#39;lmeds&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">LMEDS</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">points2E_dict</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

        <span class="n">E</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">findEssentialMat</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cameraMatrix</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">E</span></div>

<div class="viewcode-block" id="CentralCamera.decomposeE"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.decomposeE">[docs]</a>    <span class="k">def</span> <span class="nf">decomposeE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose essential matrix</span>

<span class="sd">        :param E: essential matrix</span>
<span class="sd">        :type E: ndarray(3,3)</span>
<span class="sd">        :param P: world point or feature match object to resolve ambiguity</span>
<span class="sd">        :type P: array_like(3), :class:`~machinevisiontoolbox.ImagePointFeatures.FeatureMatch`</span>
<span class="sd">        :return: camera relative pose</span>
<span class="sd">        :rtype: :class:`~spatialmath..pose3d.SE3`</span>

<span class="sd">        Determines relative pose from essential matrix. This operation has</span>
<span class="sd">        multiple solutions which is resolved by passing in:</span>

<span class="sd">        - a single 3D world point in front of the camera</span>
<span class="sd">        - a :class:`~machinevisiontoolbox.ImagePointFeatures.FeatureMatch` object</span>

<span class="sd">        :reference:</span>
<span class="sd">        - OpenCV: </span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`E` :meth:`points2E`</span>
<span class="sd">            :class:`~machinevisiontoolbox.ImagePointFeatures.FeatureMatch`</span>
<span class="sd">            `opencv.decomposeEssentialMat &lt;https://docs.opencv.org/master/d9/d0c/group__calib3d.html#ga54a2f5b3f8aeaf6c76d4a31dece85d5d&gt;`_</span>
<span class="sd">            `opencv.recoverPose &lt;https://docs.opencv.org/master/d9/d0c/group__calib3d.html#gadb7d2dfcc184c1d2f496d8639f4371c0&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">FeatureMatch</span><span class="p">):</span>
            <span class="c1"># passed a Match object</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">P</span>

            <span class="n">retval</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">recoverPose</span><span class="p">(</span>
                    <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">,</span>
                    <span class="n">points1</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                    <span class="n">points2</span><span class="o">=</span><span class="n">match</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                    <span class="n">cameraMatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="c1"># not explicitly stated, but seems that this returns (R, t) from </span>
            <span class="c1"># camera to world</span>

            <span class="k">return</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
        
            <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">decomposeEssentialMat</span><span class="p">(</span><span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>
            <span class="c1"># not explicitly stated, but seems that this returns (R, t) from </span>
            <span class="c1"># camera to world</span>

            <span class="n">possibles</span> <span class="o">=</span> <span class="p">[(</span><span class="n">R1</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">Rt</span> <span class="ow">in</span> <span class="n">possibles</span><span class="p">:</span>
                    <span class="n">pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">Rt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Rt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="n">pose</span><span class="p">,</span> <span class="n">behind</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># check if point is projected behind the camera, indicated</span>
                    <span class="c1"># by nan values</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># return the first good one</span>
                        <span class="k">return</span> <span class="n">pose</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">Rt</span> <span class="ow">in</span> <span class="n">possibles</span><span class="p">:</span>
                    <span class="n">pose</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rt</span><span class="p">(</span><span class="n">Rt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Rt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
                    <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pose</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">T</span></div>


    <span class="c1"># ===================== image plane motion ============================= #</span>

<div class="viewcode-block" id="CentralCamera.visjac_p"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.visjac_p">[docs]</a>    <span class="k">def</span> <span class="nf">visjac_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uv</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visual Jacobian for point features</span>

<span class="sd">        :param p: image plane point or points</span>
<span class="sd">        :type p: array_like(2), ndarray(2,N)</span>
<span class="sd">        :param depth: point depth</span>
<span class="sd">        :type depth: float, array_like(N)</span>
<span class="sd">        :return: visual Jacobian matrix</span>
<span class="sd">        :rtype: ndarray(2,6), ndarray(2N,6)</span>

<span class="sd">        Compute the image Jacobian :math:`\mat{J}` which maps</span>

<span class="sd">        .. math::</span>

<span class="sd">            \dvec{p} = \mat{J}(\vec{p}, z) \vec{\nu}</span>

<span class="sd">        camera spatial velocity :math:`\vec{\nu}` to the image plane velocity</span>
<span class="sd">        :math:`\dvec{p}` of the point.</span>

<span class="sd">        If ``p`` describes multiple points then return a stack of these </span>
<span class="sd">        :math:`2\times 6` matrices, one per point.</span>
<span class="sd">        </span>
<span class="sd">        Depth is the z-component of the point&#39;s coordinate in the camera frame.</span>
<span class="sd">        If ``depth`` is a scalar then it is the depth for all points. </span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.visjac_p((200, 300), 2)</span>

<span class="sd">        :references:</span>
<span class="sd">            - A tutorial on Visual Servo Control, Hutchinson, Hager &amp; Corke, </span>
<span class="sd">              IEEE Trans. R&amp;A, Vol 12(5), Oct, 1996, pp 651-670.</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 15.2.1, P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`flowfield` :meth:`visjac_p_polar` :meth:`visjac_l` :meth:`visjac_e`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">uv</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">depth</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">uv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Z must be a scalar or have same number of columns as uv&#39;</span><span class="p">)</span>
            
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  <span class="c1"># empty matrix</span>

        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
        <span class="n">Kinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">uv</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>  <span class="c1"># iterate over each column (point)</span>

            <span class="c1"># convert to normalized image-plane coordinates</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">Kinv</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">e2h</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># 2x6 Jacobian for this point</span>
            <span class="c1"># fmt: off</span>
            <span class="n">Lp</span> <span class="o">=</span> <span class="n">K</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>     <span class="n">x</span><span class="o">/</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>      <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">y</span><span class="p">],</span>
                  <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>   <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="p">,</span>   <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span>       <span class="o">-</span><span class="n">x</span><span class="p">]</span> <span class="p">])</span>
            <span class="c1"># fmt: on</span>
            <span class="c1"># stack them vertically</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">L</span><span class="p">,</span> <span class="n">Lp</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="CentralCamera.visjac_p_polar"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.visjac_p_polar">[docs]</a>    <span class="k">def</span> <span class="nf">visjac_p_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visual Jacobian for point features in polar coordinates</span>

<span class="sd">        :param p: image plane point or points</span>
<span class="sd">        :type p: array_like(2), ndarray(2,N)</span>
<span class="sd">        :param depth: point depth</span>
<span class="sd">        :type depth: float, array_like(N)</span>
<span class="sd">        :return: visual Jacobian matrix in polar coordinates</span>
<span class="sd">        :rtype: ndarray(2,6), ndarray(2N,6)</span>

<span class="sd">        Compute the image Jacobian :math:`\mat{J}` which maps</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{pmatrix} \dot{\phi} \\ \dot{r} \end{pmatrix} = \mat{J}(\vec{p}, z) \vec{\nu}</span>

<span class="sd">        camera spatial velocity :math:`\vec{\nu}` to the image plane velocity</span>
<span class="sd">        of the point expressed in polar coordinate form :math:`(\phi, r)`.</span>

<span class="sd">        If ``p`` describes multiple points then return a stack of these </span>
<span class="sd">        :math:`2\times 6` matrices, one per point.</span>
<span class="sd">        </span>
<span class="sd">        Depth is the z-component of the point&#39;s coordinate in the camera frame.</span>
<span class="sd">        If ``depth`` is a scalar then it is the depth for all points. </span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.visjac_p_polar((200, 300), 2)</span>

<span class="sd">        :references:</span>
<span class="sd">            - Combining Cartesian and polar coordinates in IBVS. </span>
<span class="sd">              Corke PI, Spindler F, Chaumette F </span>
<span class="sd">              IROS 2009, pp 59625967</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 16.2 P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`visjac_p` :meth:`visjac_l` :meth:`visjac_e`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">smbase</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">smbase</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">Z</span><span class="p">):</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="n">Z</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">Zk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>

            <span class="c1"># k = (f**2 + r**2) / f</span>
            <span class="c1"># k2 = f / (r * Zk)</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            
            <span class="n">r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span> <span class="o">-</span><span class="n">s</span><span class="o">/</span><span class="n">r</span><span class="o">/</span><span class="n">Zk</span><span class="p">,</span> <span class="n">c</span><span class="o">/</span><span class="n">r</span><span class="o">/</span><span class="n">Zk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="o">/</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="o">/</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">[</span><span class="n">c</span><span class="o">/</span><span class="n">Zk</span><span class="p">,</span> <span class="n">s</span><span class="o">/</span><span class="n">Zk</span><span class="p">,</span> <span class="o">-</span><span class="n">r</span><span class="o">/</span><span class="n">Zk</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">])</span>

            <span class="c1"># Jk = np.array([</span>
            <span class="c1">#     [     k2 * sth,     -k2 * cth,      0, f / r * cth, f / r * sth , -1],</span>
            <span class="c1">#     [-f / Zk * cth, -f / Zk * sth, r / Zk,     k * sth,     -k * cth,  0],</span>
            <span class="c1">#     ])</span>
            <span class="c1"># Jk = np.array([</span>
            <span class="c1">#     [cth/Zk , sth / Zk, -r / Zk,   -(1+r**2) * sth,     -k * cth,  0],</span>
            <span class="c1">#     [     k2 * sth,     -k2 * cth,      0, f / r * cth, f / r * sth , -1]])</span>

            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jk</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">J</span><span class="p">)</span></div>

        <span class="c1"># if 0</span>
        <span class="c1"># r = rt(1); theta = rt(2);</span>

        <span class="c1"># % compute the mapping from uv-dot to r-theta dot </span>
        <span class="c1"># M = 1/r * [r*cos(theta) r*sin(theta); -sin(theta) cos(theta)];</span>

        <span class="c1"># % convert r-theta form to uv form</span>
        <span class="c1"># u = r * cos(theta); v = r * sin(theta);</span>

        <span class="c1"># % compute the Jacobian</span>
        <span class="c1"># J = M * cam.visjac_p([u; v], Z);</span>


<div class="viewcode-block" id="CentralCamera.visjac_l"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.visjac_l">[docs]</a>    <span class="k">def</span> <span class="nf">visjac_l</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visual Jacobian for line features</span>

<span class="sd">        :param lines: image plane line parameters</span>
<span class="sd">        :type p: array_like(2), ndarray(2,N)</span>
<span class="sd">        :param plane: plane containing the line</span>
<span class="sd">        :type plane: array_like(4)</span>
<span class="sd">        :return: visual Jacobian matrix for line feature</span>
<span class="sd">        :rtype: ndarray(2,6), ndarray(2N,6)</span>

<span class="sd">        Compute the Jacobian which gives the rates of change of the line</span>
<span class="sd">        parameters in terms of camera spatial velocity. </span>

<span class="sd">        For image planes lines</span>
<span class="sd">        </span>
<span class="sd">        .. math:: u \cos \theta + v \sin \theta = \rho</span>
<span class="sd">        </span>
<span class="sd">        the image Jacobian :math:`\mat{J}` maps</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{pmatrix} \dot{\theta} \\ \dot{\rho} \end{pmatrix} = \mat{J}(\vec{p}, z) \vec{\nu}</span>

<span class="sd">        camera spatial velocity :math:`\vec{\nu}` to the image plane velocity</span>
<span class="sd">        of the line parameters :math:`(\theta, \rho)`.</span>

<span class="sd">        The world plane containing the line is also required, and is provided</span>
<span class="sd">        as a vector :math:`(a,b,c,d)` such that</span>

<span class="sd">        .. math: aX + bY +cZ + d = 0</span>

<span class="sd">        If ``lines`` describes multiple points then return a stack of these </span>
<span class="sd">        :math:`2\times 6` matrices, one per point.</span>
<span class="sd">        </span>
<span class="sd">        Depth is the z-component of the point&#39;s coordinate in the camera frame.</span>
<span class="sd">        If ``depth`` is a scalar then it is the depth for all points. </span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.visjac_l((0.2, 500), (0, 0, 1, -3))</span>

<span class="sd">        :references:</span>
<span class="sd">            - A New Approach to Visual Servoing in Robotics,</span>
<span class="sd">              B. Espiau, F. Chaumette, and P. Rives,</span>
<span class="sd">              IEEE Transactions on Robotics and Automation, </span>
<span class="sd">              vol. 8, pp. 313-326, June 1992.</span>
<span class="sd">            - Visual servo control 2: Advanced approaches</span>
<span class="sd">              Chaumette F, Hutchinson S,</span>
<span class="sd">              IEEE Robot Autom Mag 14(1):109118 (2007)</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 15.3.1, P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`visjac_p` :meth:`visjac_p_polar` :meth:`visjac_e`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">smbase</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">lines</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="n">sth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">cth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="n">lam_th</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sth</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">cth</span> <span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
            <span class="n">lam_rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">cth</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">sth</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>

            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">lam_th</span><span class="o">*</span><span class="n">cth</span><span class="p">,</span> <span class="n">lam_th</span><span class="o">*</span><span class="n">sth</span><span class="p">,</span>  <span class="o">-</span><span class="n">lam_th</span><span class="o">*</span><span class="n">rho</span><span class="p">,</span> <span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="n">cth</span><span class="p">,</span> <span class="o">-</span><span class="n">rho</span><span class="o">*</span><span class="n">sth</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">[</span><span class="n">lam_rho</span><span class="o">*</span><span class="n">cth</span><span class="p">,</span> <span class="n">lam_rho</span><span class="o">*</span><span class="n">sth</span><span class="p">,</span> <span class="o">-</span><span class="n">lam_rho</span><span class="o">*</span><span class="n">rho</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sth</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">cth</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="p">])</span>
            <span class="n">jac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">jac</span><span class="p">)</span>    </div>


<div class="viewcode-block" id="CentralCamera.visjac_e"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.visjac_e">[docs]</a>    <span class="k">def</span> <span class="nf">visjac_e</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visual Jacobian for ellipse features</span>

<span class="sd">        :param E: image plane ellipse parameters</span>
<span class="sd">        :type E: array_like(5), ndarray(5,N)</span>
<span class="sd">        :param plane: plane containing the ellipse</span>
<span class="sd">        :type plane: array_like(4)</span>
<span class="sd">        :return: visual Jacobian matrix for ellipse feature</span>
<span class="sd">        :rtype: ndarray(2,6), ndarray(2N,6)</span>

<span class="sd">        Compute the Jacobian gives the rates of change of the ellipse parameters</span>
<span class="sd">        in terms of camera spatial velocity. </span>

<span class="sd">        For image plane ellipses</span>
<span class="sd">        </span>
<span class="sd">        .. math:: u^2 + E_0 v^2 -2 E_1 u v + 2 E_2 u + 2 E_3 v + E_4 = 0</span>
<span class="sd">        </span>
<span class="sd">        the image Jacobian :math:`\mat{J}` maps</span>

<span class="sd">        .. math::</span>

<span class="sd">            \begin{pmatrix} \dot{E_0} \\ \vdots \\ \dot{E_4} \end{pmatrix} = \mat{J}(\vec{p}, z) \vec{\nu}</span>

<span class="sd">        camera spatial velocity :math:`\vec{\nu}` to the velocity</span>
<span class="sd">        of the ellipse parameters :math:`(E_0 \ldots E_4)`.</span>

<span class="sd">        The world plane containing the ellipse is also required, and is provided</span>
<span class="sd">        as a vector :math:`(a,b,c,d)` such that</span>

<span class="sd">        .. math: aX + bY +cZ + d = 0</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.visjac_e(((0.5, 0, -1000, -500, 374900)), (0, 0, 1, -1)</span>

<span class="sd">        :references:</span>
<span class="sd">            - A New Approach to Visual Servoing in Robotics,</span>
<span class="sd">              B. Espiau, F. Chaumette, and P. Rives,</span>
<span class="sd">              IEEE Transactions on Robotics and Automation, </span>
<span class="sd">              vol. 8, pp. 313-326, June 1992.</span>
<span class="sd">            - Visual servo control 2: Advanced approaches</span>
<span class="sd">              Chaumette F, Hutchinson S,</span>
<span class="sd">              IEEE Robot Autom Mag 14(1):109118 (2007)</span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 15.3.2, P. Corke, </span>
<span class="sd">              Springer 2023.</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`visjac_p` :meth:`visjac_p_polar` :meth:`visjac_l`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">plane</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">plane</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">plane</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">plane</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">plane</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">plane</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span>
            <span class="p">[</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">b</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">E</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span>
            <span class="p">])</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># not sure why...</span>
        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="CentralCamera.flowfield"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.flowfield">[docs]</a>    <span class="k">def</span> <span class="nf">flowfield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display optical flow field</span>

<span class="sd">        :param vel: camera spatial velocity</span>
<span class="sd">        :type vel: array_like(6)</span>
<span class="sd">        :param Z: _description_, defaults to 2</span>
<span class="sd">        :type Z: scalar, optional</span>

<span class="sd">        Display the optical flow field using Matplotlib, for a grid of points at</span>
<span class="sd">        distance ``Z`` for a camera velocity of ``vel``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="sd">            &gt;&gt;&gt; camera = CentralCamera.Default()</span>
<span class="sd">            &gt;&gt;&gt; camera.flowfield([0, 0, 0, 0, 1, 0])</span>

<span class="sd">        :seealso: :meth:`visjac_p`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nv</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
        <span class="p">[</span><span class="n">U</span><span class="p">,</span><span class="n">V</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>                      
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visjac_p</span><span class="p">((</span><span class="n">U</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]),</span> <span class="n">Z</span> <span class="p">)</span>            
                <span class="n">ud</span><span class="p">,</span> <span class="n">vd</span> <span class="o">=</span>  <span class="n">J</span> <span class="o">@</span> <span class="n">vel</span>
                <span class="n">du</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">ud</span>
                <span class="n">dv</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">vd</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_imageplane</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.derivatives"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute projection and derivatives for bundle adjustment</span>

<span class="sd">        :param x: camera pose as translation and quaternion vector part</span>
<span class="sd">        :type x: array_like(6)</span>
<span class="sd">        :param P: 3D world point</span>
<span class="sd">        :type P: array_like(3)</span>
<span class="sd">        :return: p, A, B</span>
<span class="sd">        :rtype: ndarray(2), ndarray(2,6), ndarray(2,3)</span>

<span class="sd">        For a world point :math:`\vec{x}` compute the image plane projection and the</span>
<span class="sd">        sensitivity to camera and point change</span>

<span class="sd">        .. math:: \mat{A} = \frac{\partial \vec{f}(\vec{x})}{\partial \pose}, \mat{B} = \frac{\partial \vec{f}(\vec{x})}{\partial \vec{P}}</span>

<span class="sd">        where :math:`\vec{f}(\vec{x})` is the perspective projection function.</span>

<span class="sd">        :seealso: :meth:`project_point`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#compute Jacobians and projection</span>

        <span class="kn">from</span>  <span class="nn">machinevisiontoolbox.camera_derivatives</span> <span class="kn">import</span> <span class="n">cameraModel</span>
        
        <span class="n">Kp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhou</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cameraModel</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">P</span><span class="p">,</span> <span class="o">*</span><span class="n">Kp</span><span class="p">)</span></div>

<div class="viewcode-block" id="CentralCamera.estpose"><a class="viewcode-back" href="../../camera-central.html#machinevisiontoolbox.Camera.CentralCamera.estpose">[docs]</a>    <span class="k">def</span> <span class="nf">estpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;iterative&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate object pose</span>

<span class="sd">        :param P: A set of 3D points defining the object with respect to its own frame</span>
<span class="sd">        :type P: ndarray(3, N)</span>
<span class="sd">        :param p: Image plane projection of the object points</span>
<span class="sd">        :type p: ndarray(2, N)</span>
<span class="sd">        :param method: pose estimation algorithm, see OpenCV solvePnP, defaults to &#39;iterative&#39;</span>
<span class="sd">        :type method: str, optional</span>
<span class="sd">        :param frame: estimate pose with respect to frame &quot;world&quot; [default] or &quot;camera&quot;</span>
<span class="sd">        :type frame: str, optional</span>
<span class="sd">        :return: pose of target frame relative to the world frame</span>
<span class="sd">        :rtype: :class:`~spatialmath..pose3d.SE3`</span>

<span class="sd">        Using a set of points defining some object with respect to its own frame {B}, and</span>
<span class="sd">        a set of image-plane projections, estimate the pose of {B} with respect to the world</span>
<span class="sd">        or camera frame.  </span>
<span class="sd">        </span>
<span class="sd">        To estimate the camera&#39;s pose with respect to the world frame the camera&#39;s pose</span>
<span class="sd">        ``self.pose`` is used.</span>

<span class="sd">        .. note::</span>
<span class="sd">        </span>
<span class="sd">            * All of the OpenCV estimation algorithms are supported.</span>
<span class="sd">            * Algorithm ``&quot;ippe-square&quot;`` requires exactly four points at the corners of a</span>
<span class="sd">              square and in the order: (-x, y), (x, y), (x, -y), (-x, -y).</span>
<span class="sd">        </span>
<span class="sd">        :seealso: :meth:`project_point`</span>
<span class="sd">            `opencv.solvePnP &lt;https://docs.opencv.org/3.4/d9/d0c/group__calib3d.html#ga549c2075fac14829ff4a58bc931c033d&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">method_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;iterative&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_ITERATIVE</span><span class="p">,</span>
            <span class="s1">&#39;epnp&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_EPNP</span><span class="p">,</span>
            <span class="s1">&#39;p3p&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_P3P</span><span class="p">,</span>
            <span class="s1">&#39;ap3p&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_AP3P</span><span class="p">,</span>
            <span class="s1">&#39;ippe&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_IPPE</span><span class="p">,</span>
            <span class="s1">&#39;ippe-square&#39;</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">SOLVEPNP_IPPE_SQUARE</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># as per the Note on solvePnP page</span>
        <span class="c1">#  we need to ensure that the image point data is contiguous nx1x2 array</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># do the pose estimation</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">solvePnP</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distortion</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">method_dict</span><span class="p">[</span><span class="n">method</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># pose of target with respect to camera</span>
            <span class="n">pose_C_T</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">SE3</span><span class="o">.</span><span class="n">EulerVec</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># pose with respect to world frame</span>
            <span class="k">if</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;camera&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pose_C_T</span>
            <span class="k">elif</span> <span class="n">frame</span> <span class="o">==</span> <span class="s2">&quot;world&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span> <span class="o">*</span> <span class="n">pose_C_T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;bad frame value </span><span class="si">{</span><span class="n">frame</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="FishEyeCamera"><a class="viewcode-back" href="../../camera-fisheye.html#machinevisiontoolbox.Camera.FishEyeCamera">[docs]</a><span class="k">class</span> <span class="nc">FishEyeCamera</span><span class="p">(</span><span class="n">CameraBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. inheritance-diagram:: machinevisiontoolbox.Camera.FishEyeCamera</span>
<span class="sd">        :top-classes: machinevisiontoolbox.Camera.Camera</span>
<span class="sd">        :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;equiangular&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create fisheye camera projection model</span>

<span class="sd">        :param k: scale factor</span>
<span class="sd">        :type k: float, optional</span>
<span class="sd">        :param projection: projection model: ``&#39;equiangular&#39;`` [default], ``&#39;sine&#39;``, ``&#39;equisolid&#39;`` or ``&#39;stereographic&#39;``</span>
<span class="sd">        :type projection: str, optional</span>
<span class="sd">        :param kwargs: arguments passed to :class:`CameraBase` constructor</span>

<span class="sd">        A fisheye camera contains a wide angle lens, and the angle of the</span>
<span class="sd">        incoming ray is mapped to a radius with respect to the principal point.</span>
<span class="sd">        The mapping from elevation angle :math:`\theta` to image plane radius is</span>
<span class="sd">        given by:</span>

<span class="sd">            =============   =======================================</span>
<span class="sd">            Projection      :math:`r(\theta)`</span>
<span class="sd">            =============   =======================================</span>
<span class="sd">            equiangular     :math:`r = k \theta`</span>
<span class="sd">            sine            :math:`r = k \sin \theta`</span>
<span class="sd">            equisolid       :math:`r = k \sin \frac{\theta}{2}`</span>
<span class="sd">            stereographic   :math:`r = k \tan \frac{\theta}{2}`</span>
<span class="sd">            =============   =======================================</span>

<span class="sd">        .. note:: </span>
<span class="sd">            - If ``K`` is not specified it is computed such that the circular</span>
<span class="sd">              imaging region maximally fills the square image plane.</span>
<span class="sd">            - This camera model assumes central projection, that is, the focal point</span>
<span class="sd">              is at z=0 and the image plane is at z=f.  The image is not inverted.</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.3.1, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`CameraBase` :class:`CentralCamera` :class:`CatadioptricCamera`</span>
<span class="sd">            :class:`SphericalCamera` </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camtype</span><span class="o">=</span><span class="s1">&#39;fisheye&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span>

        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pp</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;equiangular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">theta</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;sine&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;equisolid&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;stereographic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown projection model&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfunc</span> <span class="o">=</span> <span class="n">rfunc</span>
        
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{:.4g}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>        
        
<div class="viewcode-block" id="FishEyeCamera.project_point"><a class="viewcode-back" href="../../camera-fisheye.html#machinevisiontoolbox.Camera.FishEyeCamera.project_point">[docs]</a>    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D points to image plane</span>

<span class="sd">        :param P: 3D world point or points</span>
<span class="sd">        :type P: array_like(3), array_like(3,n)</span>
<span class="sd">        :param pose: camera pose with respect to the world frame, defaults to</span>
<span class="sd">            camera&#39;s ``pose`` attribute</span>
<span class="sd">        :type pose: SE:class:`~spatialmath..pose3d.SE3`3, optional</span>
<span class="sd">        :param objpose:  3D point reference frame, defaults to world frame</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param visibility: test if points are visible, default False</span>
<span class="sd">        :type visibility: bool</span>
<span class="sd">        :raises ValueError: [description]</span>
<span class="sd">        :return: image plane points</span>
<span class="sd">        :rtype: ndarray(2,n)</span>

<span class="sd">        Project world points to the fisheye camera image plane.</span>

<span class="sd">        The elevation angle range is from :math:`-pi/2` (below the mirror) to</span>
<span class="sd">        maxangle above the horizontal plane. The mapping from elevation angle</span>
<span class="sd">        :math:`\theta` to image plane radius is given by:</span>

<span class="sd">            =============   =======================================</span>
<span class="sd">            Projection      :math:`r(\theta)`</span>
<span class="sd">            =============   =======================================</span>
<span class="sd">            equiangular     :math:`r = k \theta`</span>
<span class="sd">            sine            :math:`r = k \sin \theta`</span>
<span class="sd">            equisolid       :math:`r = k \sin \frac{\theta}{2}`</span>
<span class="sd">            stereographic   :math:`r = k \tan \frac{\theta}{2}`</span>
<span class="sd">            =============   =======================================</span>
<span class="sd">        </span>
<span class="sd">        World points are given as a 1D array or the columns of a 2D array of</span>
<span class="sd">        Euclidean coordinates. The computed image plane coordinates are</span>
<span class="sd">        Euclidean and given as a 1D array or the corresponding columns of a 2D</span>
<span class="sd">        array.</span>

<span class="sd">        If ``pose`` is specified it is used for the camera pose instead of the</span>
<span class="sd">        attribute ``pose``.  The object&#39;s attribute is not updated.</span>

<span class="sd">        The points ``P`` are by default with respect to the world frame, but </span>
<span class="sd">        they can be transformed by specifying ``objpose``.</span>

<span class="sd">        :seealso: :meth:`plot_point`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">objpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">*=</span> <span class="n">objpose</span>
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span>
        
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfunc</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        
        <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhou</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhov</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise_distortion</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span></div></div>

<span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="CatadioptricCamera"><a class="viewcode-back" href="../../camera-catadiop.html#machinevisiontoolbox.Camera.CatadioptricCamera">[docs]</a><span class="k">class</span> <span class="nc">CatadioptricCamera</span><span class="p">(</span><span class="n">CameraBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. inheritance-diagram:: machinevisiontoolbox.Camera.CatadioptricCamera</span>
<span class="sd">        :top-classes: machinevisiontoolbox.Camera.Camera</span>
<span class="sd">        :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;equiangular&#39;</span><span class="p">,</span> <span class="n">maxangle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create catadioptric camera projection model</span>

<span class="sd">        :param k: scale factor</span>
<span class="sd">        :type k: float, optional</span>
<span class="sd">        :param projection: projection model: ``&#39;equiangular&#39;`` [default], ``&#39;sine&#39;``, ``&#39;equisolid&#39;`` or ``&#39;stereographic&#39;``</span>
<span class="sd">        :type projection: str, optional</span>
<span class="sd">        :param kwargs: arguments passed to :class:`CameraBase` constructor</span>

<span class="sd">        A catadioptric camera comprises a perspective camera pointed at a </span>
<span class="sd">        convex mirror, typically paraboloidal or conical.</span>
<span class="sd">        </span>
<span class="sd">        The elevation angle range is from :math:`-\pi/2` (below the mirror) to</span>
<span class="sd">        maxangle above the horizontal plane. The mapping from elevation angle</span>
<span class="sd">        :math:`\theta` to image plane radius is given by:</span>

<span class="sd">            =============   =======================================</span>
<span class="sd">            Projection      :math:`r(\theta)`</span>
<span class="sd">            =============   =======================================</span>
<span class="sd">            equiangular     :math:`r = k \theta`</span>
<span class="sd">            sine            :math:`r = k \sin \theta`</span>
<span class="sd">            equisolid       :math:`r = k \sin \frac{\theta}{2}`</span>
<span class="sd">            stereographic   :math:`r = k \tan \frac{\theta}{2}`</span>
<span class="sd">            =============   =======================================</span>


<span class="sd">        .. note::</span>
<span class="sd">            - If ``K`` is not specified it is computed such that the circular</span>
<span class="sd">              imaging region maximally fills the image plane.</span>
<span class="sd">            - This camera model assumes central projection, that is, the focal point</span>
<span class="sd">              is at z=0 and the image plane is at z=f.  The image is not inverted.</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.3.2, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`CameraBase` :class:`CentralCamera` :class:`FishEyeCamera`</span>
<span class="sd">            :class:`SphericalCamera`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camtype</span><span class="o">=</span><span class="s1">&#39;catadioptric&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">=</span> <span class="n">projection</span>
    
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">imagesize</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pp</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>

        <span class="c1"># compute k if not specified, so that hemisphere fits into</span>
        <span class="c1"># image plane, requires maxangle being set</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;equiangular&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">maxangle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">maxangle</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">maxangle</span> <span class="o">=</span> <span class="n">maxangle</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must specify either k or maxangle&#39;</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">theta</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;sine&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;equisolid&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;stereographic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">rfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown projection model&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfunc</span> <span class="o">=</span> <span class="n">rfunc</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{:.4g}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="CatadioptricCamera.project_point"><a class="viewcode-back" href="../../camera-catadiop.html#machinevisiontoolbox.Camera.CatadioptricCamera.project_point">[docs]</a>    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D points to image plane</span>

<span class="sd">        :param P: 3D world point or points</span>
<span class="sd">        :type P: array_like(3), array_like(3,n)</span>
<span class="sd">        :param pose: camera pose with respect to the world frame, defaults to</span>
<span class="sd">            camera&#39;s ``pose`` attribute</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param objpose:  3D point reference frame, defaults to world frame</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param visibility: test if points are visible, default False</span>
<span class="sd">        :type visibility: bool</span>
<span class="sd">        :raises ValueError: [description]</span>
<span class="sd">        :return: image plane points</span>
<span class="sd">        :rtype: ndarray(2,n)</span>

<span class="sd">        Project world points to the catadioptric camera image plane.</span>

<span class="sd">        World points are given as a 1D array or the columns of a 2D array of</span>
<span class="sd">        Euclidean coordinates. The computed image plane coordinates are</span>
<span class="sd">        Euclidean and given as a 1D array or the corresponding columns of a 2D</span>
<span class="sd">        array.</span>

<span class="sd">        If ``pose`` is specified it is used for the camera pose instead of the</span>
<span class="sd">        attribute ``pose``.  The object&#39;s attribute is not updated.</span>

<span class="sd">        The points ``P`` are by default with respect to the world frame, but </span>
<span class="sd">        they can be transformed by specifying ``objpose``.</span>

<span class="sd">        :seealso: :meth:`plot_point`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">objpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">*=</span> <span class="n">objpose</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">T</span> <span class="o">*</span> <span class="n">P</span>  <span class="c1"># transform points to camera frame</span>
    
        <span class="c1"># project to the image plane</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">P</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span>
        
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfunc</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="c1"># depends on projection model</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        
        <span class="n">uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhou</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">u0</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhov</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">v0</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise_distortion</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span></div></div>

<span class="c1"># ------------------------------------------------------------------------ #</span>
<div class="viewcode-block" id="SphericalCamera"><a class="viewcode-back" href="../../camera-spherical.html#machinevisiontoolbox.Camera.SphericalCamera">[docs]</a><span class="k">class</span> <span class="nc">SphericalCamera</span><span class="p">(</span><span class="n">CameraBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. inheritance-diagram:: machinevisiontoolbox.Camera.SphericalCamera</span>
<span class="sd">        :top-classes: machinevisiontoolbox.Camera.Camera</span>
<span class="sd">        :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>    
        
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create spherical camera projection model</span>

<span class="sd">        :param kwargs: arguments passed to :class:`CameraBase` constructor</span>

<span class="sd">        The spherical camera is an idealization with a complete field of view</span>
<span class="sd">        that can be used to generalize all camera projection models.</span>

<span class="sd">        :references: </span>
<span class="sd">            - Robotics, Vision &amp; Control for Python, Section 13.3.3, P. Corke, Springer 2023.</span>

<span class="sd">        :seealso: :class:`CameraBase` :class:`CentralCamera` :class:`CatadioptricCamera`</span>
<span class="sd">            :class:`FishEyeCamera` </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># invoke the superclass constructor</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">camtype</span><span class="o">=</span><span class="s1">&#39;spherical&#39;</span><span class="p">,</span> 
            <span class="n">limits</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">pi</span><span class="p">],</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Longitude  (rad)&#39;</span><span class="p">,</span> <span class="s1">&#39;Colatitude  (rad)&#39;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># return field-of-view angle for x and y direction (rad)</span>
<div class="viewcode-block" id="SphericalCamera.fov"><a class="viewcode-back" href="../../camera-spherical.html#machinevisiontoolbox.Camera.SphericalCamera.fov">[docs]</a>    <span class="k">def</span> <span class="nf">fov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Camera field-of-view angles</span>

<span class="sd">        :return: field of view angles in radians</span>
<span class="sd">        :rtype: ndarray(2)</span>
<span class="sd">        </span>
<span class="sd">        Computes the field of view angles (2x1) in radians for the camera</span>
<span class="sd">        horizontal and vertical directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="SphericalCamera.project_point"><a class="viewcode-back" href="../../camera-spherical.html#machinevisiontoolbox.Camera.SphericalCamera.project_point">[docs]</a>    <span class="k">def</span> <span class="nf">project_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">pose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">objpose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Project 3D points to image plane</span>

<span class="sd">        :param P: 3D world point or points</span>
<span class="sd">        :type P: array_like(3), array_like(3,n)</span>
<span class="sd">        :param pose: camera pose with respect to the world frame, defaults to</span>
<span class="sd">            camera&#39;s ``pose`` attribute</span>
<span class="sd">        :type pose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :param objpose:  3D point reference frame, defaults to world frame</span>
<span class="sd">        :type objpose: :class:`~spatialmath..pose3d.SE3`, optional</span>
<span class="sd">        :return: image plane points</span>
<span class="sd">        :rtype: ndarray(2,n)</span>

<span class="sd">        Project world points to the spherical camera image plane.</span>
<span class="sd">        </span>
<span class="sd">        World points are given as a 1D array or the columns of a 2D array of</span>
<span class="sd">        Euclidean coordinates. The computed image plane coordinates are</span>
<span class="sd">        in polar form :math:`(\phi, \theta)` (longitude, colatitude),</span>
<span class="sd">        and given as a 1D array or the corresponding columns of a 2D</span>
<span class="sd">        array.</span>

<span class="sd">        If ``pose`` is specified it is used for the camera pose instead of the</span>
<span class="sd">        attribute ``pose``.  The object&#39;s attribute is not updated.</span>

<span class="sd">        The points ``P`` are by default with respect to the world frame, but </span>
<span class="sd">        they can be transformed by specifying ``objpose``.</span>

<span class="sd">        :seealso: :meth:`plot_point`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">pose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose</span>

        <span class="n">pose</span> <span class="o">=</span> <span class="n">pose</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">objpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pose</span> <span class="o">*=</span> <span class="n">objpose</span>

        <span class="n">P</span> <span class="o">=</span> <span class="n">pose</span> <span class="o">*</span> <span class="n">P</span>         <span class="c1"># transform points to camera frame</span>
        
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">R</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">R</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">R</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">])</span></div>

<div class="viewcode-block" id="SphericalCamera.visjac_p"><a class="viewcode-back" href="../../camera-spherical.html#machinevisiontoolbox.Camera.SphericalCamera.visjac_p">[docs]</a>    <span class="k">def</span> <span class="nf">visjac_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Visual Jacobian for point features</span>

<span class="sd">        :param p: image plane points</span>
<span class="sd">        :type p: array_like(2) or ndarray(2,N)</span>
<span class="sd">        :param depth: point depth, defaults to None</span>
<span class="sd">        :type depth: float or array_like(N), optional</span>
<span class="sd">        :return: visual Jacobian</span>
<span class="sd">        :rtype: ndarray(2,6) or ndarray(2N,6)</span>

<span class="sd">        Compute the image Jacobian :math:`\mat{J}` which maps</span>

<span class="sd">        .. math::</span>

<span class="sd">            \dvec{p} = \mat{J}(\vec{p}, z) \vec{\nu}</span>

<span class="sd">        camera spatial velocity :math:`\vec{\nu}` to the image plane velocity</span>
<span class="sd">        :math:`\dvec{p}` of the point where :math:`\vec{p}=(\phi, \theta)`</span>

<span class="sd">        If ``p`` describes multiple points then return a stack of these </span>
<span class="sd">        :math:`2\times 6` matrices, one per point.</span>
<span class="sd">        </span>
<span class="sd">        Depth is the z-component of the point&#39;s coordinate in the camera frame.</span>
<span class="sd">        If ``depth`` is a scalar then it is the depth for all points. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">smbase</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">depth</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">),</span> <span class="n">R</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="n">Jk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">sp</span><span class="o">/</span><span class="n">R</span><span class="o">/</span><span class="n">st</span><span class="p">,</span> <span class="o">-</span><span class="n">cp</span><span class="o">/</span><span class="n">R</span><span class="o">/</span><span class="n">st</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">st</span><span class="p">,</span> <span class="n">sp</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">st</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">cp</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">R</span><span class="p">,</span> <span class="o">-</span><span class="n">sp</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">R</span><span class="p">,</span> <span class="n">st</span><span class="o">/</span><span class="n">R</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="p">])</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">J</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalCamera.plot"><a class="viewcode-back" href="../../camera-spherical.html#machinevisiontoolbox.Camera.SphericalCamera.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">smbase</span><span class="o">.</span><span class="n">plot_sphere</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightyellow&#39;</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pose</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s1">&#39;arrow&#39;</span><span class="p">,</span> <span class="n">axislabel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span></div></div>



<span class="c1"># class CentralCamera_polar(Camera):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Central projection camera class</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self,</span>
<span class="c1">#                  f=1,</span>
<span class="c1">#                  distortion=None,</span>
<span class="c1">#                  **kwargs):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create central camera projection model in polar coordinates</span>

<span class="c1">#         :param f: focal length, defaults to 8*1e-3</span>
<span class="c1">#         :type f: float, optional</span>
<span class="c1">#         :param distortion: camera distortion parameters, defaults to None</span>
<span class="c1">#         :type distortion: array_like(5), optional</span>

<span class="c1">#         :seealso: :meth:`distort`</span>
<span class="c1">#         &quot;&quot;&quot;</span>

<span class="c1">#         super().__init__(type=&#39;perspective&#39;, **kwargs)</span>
<span class="c1">#         # TODO some of this logic to f and pp setters</span>
<span class="c1">#         self.f = f</span>

<span class="c1">#         self._distortion = distortion</span>

<span class="c1">#     @classmethod</span>
<span class="c1">#     def Default(cls, **kwargs):</span>
<span class="c1">#         default = {</span>
<span class="c1">#             &#39;f&#39;: 0.008, </span>
<span class="c1">#             &#39;rho&#39;: 10e-6,</span>
<span class="c1">#             &#39;imagesize&#39;: 1000, </span>
<span class="c1">#             &#39;pp&#39;: (500,500),</span>
<span class="c1">#             &#39;name&#39;: &#39;default perspective camera&#39;</span>
<span class="c1">#         }</span>

<span class="c1">#         return CentralCamera_polar(**{**default, **kwargs})</span>
        
<span class="c1">#     def __str__(self):</span>
<span class="c1">#         s = super().__str__()</span>
<span class="c1">#         s += self.fmt.format(&#39;principal pt&#39;, self.pp)</span>
<span class="c1">#         s += self.fmt.format(&#39;focal length&#39;, self.f)</span>

<span class="c1">#         return s</span>


<span class="c1">#     def project_point(self, P, pose=None, objpose=None, **kwargs):</span>
<span class="c1">#         r&quot;&quot;&quot;</span>
<span class="c1">#         Project 3D points to image plane</span>

<span class="c1">#         :param P: 3D points to project into camera image plane</span>
<span class="c1">#         :type P: array_like(3), array_like(3,n)</span>
<span class="c1">#         :param pose: camera pose with respect to the world frame, defaults to</span>
<span class="c1">#             camera&#39;s ``pose`` attribute</span>
<span class="c1">#         :type pose: SE3, optional</span>
<span class="c1">#         :param objpose:  3D point reference frame, defaults to world frame</span>
<span class="c1">#         :type objpose: SE3, optional</span>
<span class="c1">#         :param visibility: test if points are visible, default False</span>
<span class="c1">#         :type visibility: bool</span>
<span class="c1">#         :param retinal: transform to retinal coordinates, default False</span>
<span class="c1">#         :type retinal: bool, optional</span>
<span class="c1">#         :return: image plane points</span>
<span class="c1">#         :rtype: ndarray(2,n)</span>

<span class="c1">#         Project a 3D point to the image plane</span>

<span class="c1">#         .. math::</span>

<span class="c1">#             \hvec{p} = \mat{C} \hvec{P}</span>

<span class="c1">#         where :math:`\mat{C}` is the camera calibration matrix and :math:`\hvec{p}` and :math:`\hvec{P}`</span>
<span class="c1">#         are the image plane and world frame coordinates respectively.</span>

<span class="c1">#         Example:</span>

<span class="c1">#         .. runblock:: pycon</span>

<span class="c1">#             &gt;&gt;&gt; from machinevisiontoolbox import CentralCamera</span>
<span class="c1">#             &gt;&gt;&gt; camera = CentralCamera()</span>
<span class="c1">#             &gt;&gt;&gt; camera.project_point((0.3, 0.4, 2))</span>

<span class="c1">#         If ``pose`` is specified it is used for the camera frame pose, otherwise</span>
<span class="c1">#         the attribute ``pose``.  The object&#39;s ``pose`` attribute is not updated</span>
<span class="c1">#         if ``pose`` is specified.</span>

<span class="c1">#         A single point can be specified as a 3-vector, multiple points as an</span>
<span class="c1">#         array with three rows and one column (x, y, z) per point.</span>

<span class="c1">#         The points ``P`` are by default with respect to the world frame, but </span>
<span class="c1">#         they can be transformed by specifying ``objpose``.</span>
        
<span class="c1">#         If world points are behind the camera, the image plane points are set to</span>
<span class="c1">#         NaN.</span>
        
<span class="c1">#         if ``visibility`` is True then each projected point is checked to ensure</span>
<span class="c1">#         it lies in the bounds of the image plane.  In this case there are two</span>
<span class="c1">#         return values: the image plane coordinates and an array of booleans</span>
<span class="c1">#         indicating if the corresponding point is visible.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if pose is None:</span>
<span class="c1">#             pose = self.pose</span>

<span class="c1">#         C = self.C(pose, retinal=retinal)</span>

<span class="c1">#         if isinstance(P, np.ndarray):</span>
<span class="c1">#             if P.ndim == 1:</span>
<span class="c1">#                 P = P.reshape((-1, 1))  # make it a column</span>
<span class="c1">#         else:</span>
<span class="c1">#             P = base.getvector(P, out=&#39;col&#39;)</span>

<span class="c1">#         # make it homogeneous if not already</span>
<span class="c1">#         if P.shape[0] == 3:</span>
<span class="c1">#             P = base.e2h(P)</span>

<span class="c1">#         # project 3D points</span>

<span class="c1">#         if objpose is not None:</span>
<span class="c1">#             P = objpose.A @ P</span>

<span class="c1">#         x = C @ P</span>

<span class="c1">#         if behind:</span>
<span class="c1">#             x[2, x[2, :] &lt; 0] = np.nan  # points behind the camera are set to NaN</span>

<span class="c1">#         x = base.h2e(x)</span>

<span class="c1">#         # add Gaussian noise and distortion</span>
<span class="c1">#         x = self.add_noise_distortion(x)</span>

<span class="c1">#         #  do visibility check if required</span>
<span class="c1">#         if visibility:</span>
<span class="c1">#             visible = ~np.isnan(x[0,:]) \</span>
<span class="c1">#                 &amp; (x[0, :] &gt;= 0) \</span>
<span class="c1">#                 &amp; (x[1, :] &gt;= 0) \</span>
<span class="c1">#                 &amp; (x[0, :] &lt; self.nu) \</span>
<span class="c1">#                 &amp; (x[1, :] &lt; self.nv)</span>
            
<span class="c1">#             return x, visible</span>
<span class="c1">#         else:</span>
<span class="c1">#             return x</span>

<span class="c1">#     def plot_point(self, Pp</span>
<span class="c1">#         ax = _newplot(self, fig, ax)</span>

<span class="c1">#         if self._image is not None:</span>
<span class="c1">#             # if camera has an image, display said image</span>
<span class="c1">#             idisp(self._image,</span>
<span class="c1">#                       fig=fig,</span>
<span class="c1">#                       ax=ax,</span>
<span class="c1">#                       title=self._name,</span>
<span class="c1">#                       drawonly=True)</span>
<span class="c1">#         else:</span>
<span class="c1">#             if self.limits is None:</span>
<span class="c1">#                 ax.set_xlim(0, self.nu)</span>
<span class="c1">#                 ax.set_ylim(0, self.nv)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 ax.set_xlim(self.limits[0], self.limits[1])</span>
<span class="c1">#                 ax.set_ylim(self.limits[2], self.limits[3])</span>
<span class="c1">#             ax.autoscale(False)</span>
<span class="c1">#             ax.set_aspect(&#39;equal&#39;)</span>
<span class="c1">#             ax.invert_yaxis()</span>
<span class="c1">#             ax.grid(True)</span>
<span class="c1">#             if self.labels is None:</span>
<span class="c1">#                 ax.set_xlabel(&#39;u (pixels)&#39;)</span>
<span class="c1">#                 ax.set_ylabel(&#39;v (pixels)&#39;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 ax.set_xlabel(self.labels[0])</span>
<span class="c1">#                 ax.set_ylabel(self.labels[1])</span>
<span class="c1">#             ax.set_title(self.name)</span>
<span class="c1">#             ax.set_facecolor(&#39;lightyellow&#39;)</span>
<span class="c1">#             ax.figure.canvas.set_window_title(&#39;Machine Vision Toolbox for Python&#39;)</span>

<span class="c1">#         # TODO figure out axes ticks, etc</span>
<span class="c1">#         return ax  # likely this return is not necessary</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">UnitQuaternion</span>

    <span class="c1"># im1 = Image.Read(&quot;eiffel2-1.png&quot;, grey=True)</span>
    <span class="c1"># camera = CentralCamera();</span>
    <span class="c1"># camera.disp(im1);</span>


    <span class="c1"># cam = CentralCamera(f=0.08)</span>
    <span class="c1"># print(cam)</span>
    <span class="c1"># P = [0.1, 0.2, 3]</span>
    <span class="c1"># print(cam.project_point(P))</span>

    <span class="n">cam</span> <span class="o">=</span> <span class="n">CentralCamera</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">imagesize</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mf">10e-6</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>

    <span class="n">cam</span><span class="o">.</span><span class="n">project_point</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

    <span class="c1"># P = np.array([[0, 10], [0, 10], [10, 10]])</span>
    <span class="c1"># p, visible = cam.project_point(P, visibility=True)</span>
    <span class="c1"># visible</span>

    <span class="c1"># P = [0.1, 0.2, 3]</span>
    <span class="c1"># print(cam.project_point(P))</span>


    <span class="c1"># T1 = SE3(-0.1, 0, 0) * SE3.Ry(0.4);</span>
    <span class="c1"># camera1 = CentralCamera(name=&quot;camera 1&quot;, f=0.002, imagesize=1000, rho=10e-6, pose=T1)</span>
    <span class="c1"># # print(camera1)</span>

    <span class="c1"># camera1.decomposeH(np.eye(3,3))</span>


    <span class="c1"># L = Line3.TwoPoints([0, 0, 1], [1, 1, 1])</span>
    <span class="c1"># camera = CentralCamera.Default();</span>
    <span class="c1"># l = camera.project_line(L)</span>
    <span class="c1"># camera.plot_line3(L)</span>


    <span class="c1"># x = np.r_[cam.pose.t, UnitQuaternion(cam.pose).vec3]</span>
    <span class="c1"># print(x)</span>
    <span class="c1"># p, JA, JB = cam.derivatives(x, P)</span>
    <span class="c1"># print(p)</span>
    <span class="c1"># print(cam.project_point(P))</span>
    <span class="c1"># print(JA)</span>
    <span class="c1"># print(JB)</span>

    <span class="c1"># smbase.plotvol3(2)</span>

    <span class="c1"># cam.plot_camera(scale=0.5, shape=&#39;camera&#39;, T=SE3.Ry(np.pi/2))</span>

    <span class="c1"># plt.show(block=True)</span>
    <span class="c1"># print(cam)</span>
    <span class="c1"># # cam.pose = SE3([0.1, 0.2, 0.3])</span>
    <span class="c1"># print(cam.pose)</span>
    <span class="c1"># # fig, ax = c.plot_camera(frustum=True)</span>
    <span class="c1"># # plt.show()</span>
    <span class="c1"># np.set_printoptions(linewidth=120, formatter={&#39;float&#39;: lambda x: f&quot;{x:8.4g}&quot; if abs(x) &gt; 1e-10 else f&quot;{0:8.4g}&quot;})</span>


    <span class="c1"># print(cam.project([1,2,3]))</span>

    <span class="c1"># print(cam.visjac_p((300,300), 1))</span>
    <span class="c1"># cam.flowfield([0,0,0, 0,0,1])</span>
    <span class="c1"># # fundamental matrix</span>
    <span class="c1"># # create +8 world points (20 in this case)</span>
    <span class="c1"># nx, ny = (4, 5)</span>
    <span class="c1"># depth = 3</span>
    <span class="c1"># x = np.linspace(-1, 1, nx)</span>
    <span class="c1"># y = np.linspace(-1, 1, ny)</span>
    <span class="c1"># X, Y = np.meshgrid(x, y)</span>
    <span class="c1"># Z = depth * np.ones(X.shape)</span>
    <span class="c1"># P = np.dstack((X, Y, Z))</span>
    <span class="c1"># PC = np.ravel(P, order=&#39;C&#39;)</span>
    <span class="c1"># PW = np.reshape(PC, (3, nx * ny), order=&#39;F&#39;)</span>

    <span class="c1"># # create projections from pose 1:</span>
    <span class="c1"># print(c.T)</span>
    <span class="c1"># p1 = c.project(PW)  # p1 wrt c&#39;s T</span>
    <span class="c1"># print(p1)</span>
    <span class="c1"># c.plot(PW)</span>

    <span class="c1"># # define pose 2:</span>
    <span class="c1"># T2 = SE3([0.4, 0.2, 0.3])  # just pure x-translation</span>
    <span class="c1"># p2 = c.project(PW, T2)</span>
    <span class="c1"># print(p2)</span>
    <span class="c1"># c.plot(p2)</span>

    <span class="c1"># # convert p1, p2 into lists of points?</span>
    <span class="c1"># p1 = np.float32(np.transpose(p1))</span>
    <span class="c1"># p2 = np.float32(np.transpose(p2))</span>
    <span class="c1"># F = c.FfromPoints(p1,</span>
    <span class="c1">#                   p2,</span>
    <span class="c1">#                   method=&#39;8p&#39;,</span>
    <span class="c1">#                   ransacThresh=3,</span>
    <span class="c1">#                   confidence=0.99,</span>
    <span class="c1">#                   maxiters=10)</span>

    <span class="c1"># # to check F:</span>
    <span class="c1"># p1h = e2h(p1.T)</span>
    <span class="c1"># p2h = e2h(p2.T)</span>
    <span class="c1"># pfp = [p2h[:, i].T @ F @ p1h[:, i] for i in range(p1h.shape[1])]</span>
    <span class="c1"># # [print(pfpi) for pfpi in pfp]</span>
    <span class="c1"># for pfpi in pfp:</span>
    <span class="c1">#     print(pfpi)</span>
    <span class="c1"># # should be all close to zero, which they are!</span>

    <span class="c1"># # essential matrix from points:</span>
    <span class="c1"># E = c.EfromPoints(p1, p2, c.C)</span>

    <span class="c1"># # TODO verify E</span>

    <span class="c1"># import code</span>
    <span class="c1"># code.interact(local=dict(globals(), **locals()))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-, Peter Corke.
      <span class="lastupdated">Last updated on 26-Sep-2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>